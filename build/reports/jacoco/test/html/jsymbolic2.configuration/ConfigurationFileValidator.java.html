<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConfigurationFileValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jSymbolic2</a> &gt; <a href="index.source.html" class="el_package">jsymbolic2.configuration</a> &gt; <span class="el_source">ConfigurationFileValidator.java</span></div><h1>ConfigurationFileValidator.java</h1><pre class="source lang-java linenums">package jsymbolic2.configuration;

import jsymbolic2.processing.UserFeedbackGenerator;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.List;

/**
 * &lt;p&gt;
 * A general class for implementing a configuration file validator for the jSymbolic program.
 * Methods have been separated into validation for the configuration file itself,
 * features, options, input files and output files.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Each abstract method should be implemented to validate and parse the configuration file depending
 * on the chosen format of the configuration file. Each corresponding method should then return
 * the appropriate file object, with the data that jSymbolic requires from the configuration file.
 * &lt;/p&gt;
 * &lt;p&gt;
 * In particular, the {@link #parseConfigFile(String, List, PrintStream)} method is not abstract and uses the template method pattern
 * to return an object the contains all the appropriate configuration file data. This method runs
 * the abstract functions in the correct order and also deals with exception handling.
 * Exception handling is dealt with by printing the particular error to console and then exiting
 * with a status code of -1.
 * &lt;/p&gt;
 *
 * @author Tristano Tenaglia
 */
<span class="fc" id="L32">public abstract class ConfigurationFileValidator {</span>

    /**
     * Validate the features syntax specified in the configuration file.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @return A list of the entire configuration file with validated feature syntax.
     * @throws Exception If syntax is not valid for features in configuration file.
     */
    public abstract List&lt;String&gt; validateFeatureSyntax(List&lt;String&gt; rawConfigFile, File configurationFile) throws Exception;

    /**
     * Validate the features logic specified in the configuration file.
     * This occurs after the feature syntax validation in the {@link #parseConfigFile(String, List, PrintStream)} function.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @return A list of string containing the line by line raw configuration file with feature logic validated.
     * @throws Exception If logic is not valid for features in configuration file.
     */
    public abstract List&lt;String&gt; validateFeatureLogic(List&lt;String&gt; rawConfigFile, File configurationFile) throws Exception;

    /**
     * Validate the options syntax specified in the configuration file.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @return ConfigurationOptionState based on the actual state of the configuration options.
     * @throws Exception If syntax is not valid for options in the configuration file.
     */
    public abstract ConfigurationOptionState validateOptionSyntax(List&lt;String&gt; rawConfigFile, File configurationFile) throws Exception;

    /**
     * Validate the options logic specified in the configuration file.
     * This occurs after the option syntax validation in the parseConfigFile(String, List, PrintSteram) method.
     *
     * @param configOption      The syntax validated configuration option data.
     * @param configurationFile The configuration file for file information.
     * @return ConfigurationOptionState The fully validated state of the configuration options from the configuration file.
     * @throws Exception If logic is not valid for options in the configuration file.
     */
    public abstract ConfigurationOptionState validateOptionLogic(ConfigurationOptionState configOption, File configurationFile) throws Exception;

    /**
     * Validate the input files in the specified configuration file.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @return ConfigurationInputFiles Both the valid and invalid input files that need to be processed.
     * @throws Exception Thrown when invalid input file syntax/logic is found in the configuration file.
     */
    public abstract ConfigurationInputFiles checkForInvalidInputFiles(List&lt;String&gt; rawConfigFile, File configurationFile) throws Exception;

    /**
     * Validate the output files in the specified configuration file.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @return ConfigurationOutputFiles Returns the feature value save path and the feature description save path.
     * @throws Exception Thrown when invalid output file syntax/logic is found in the configuration file.
     */
    public abstract ConfigurationOutputFiles checkForInvalidOutputFiles(List&lt;String&gt; rawConfigFile, File configurationFile) throws Exception;

    /**
     * Validate the header syntax in the specified configuration file.
     *
     * @param rawConfigFile     A list of strings containing the line by line raw configuration file.
     * @param configurationFile The configuration file for file information.
     * @param headersToCheck    The headers that need to be validated. Headers not contained in this list will
     *                          not be validated.
     * @throws Exception Thrown when configuration file is missing a header or has wrong header syntax on the headers
     *                   that it needs to check.
     */
    public abstract void validateHeaders(List&lt;String&gt; rawConfigFile, File configurationFile, List&lt;ConfigFileHeaderEnum&gt; headersToCheck) throws Exception;

    /**
     * Extract from the configuration file a list of strings containing the line by line raw configuration file.
     *
     * @param configurationFile The configuration file that needs to be extracted from.
     * @return A list of strings containing the line by line raw configuration file.
     * @throws IOException Thrown if the configurationFile is not valid.
     */
    public abstract List&lt;String&gt; extractRawConfigurationFile(File configurationFile) throws IOException;

    /**
     * Validates the specified configuration file name. In particular, it validates if it is indeed a file and
     * if the name is right.
     *
     * @param configurationFile The configuration file name that will be verified.
     * @return A valid file created from the configuration file name input.
     * @throws Exception Thrown if the name or the file itself is not valid.
     */
    public abstract File checkConfigFile(String configurationFile) throws Exception;

    /**
     * IMPORTANT: If a specific header does not need to be checked, then the value of the corresponding
     * data in the returned ConfigurationFileData object will be set to null. For example,
     * if input files and output save paths are specified in the command line instead of the configuration file,
     * then this function will return a ConfigurationFileData object with all the appropriate data
     * but the ConfigurationInputFiles Object and the ConfigurationOutputFiles object will be set to null.
     * &lt;p&gt;
     * Convenience template method pattern to allow one function call to validate configuration file.
     * This design pattern specifies order of function call but not implementation, which is left
     * up to the programmer and depends on the format of the configuration file.
     * Notice that configFile null is not checked as this should be done
     * in the checkConfigFile function implementation.
     *
     * @param configurationFileName The configuration file name that needs to be validated.
     * @param headersToCheck        Headers that need to be validated in configuration file.
     *                              Any headers not specified here will result in an exception and thus
     *                              this method will print usage on error and then terminate the jSymbolic program.
     * @param error_stream          A print stream to write errors to.
     * @return ConfigurationFileData object which contains all the appropriate data extracted and validated
     * from the specified configuration file. Only headers that need to be checked will return appropriate data.
     * All headers that need not be checked will be returned as null in the ConfigurationFileData return object.
     * @throws Exception Thrown if configuration file is not valid.
     */
    public ConfigurationFileData parseConfigFile(String configurationFileName,
                                                 List&lt;ConfigFileHeaderEnum&gt; headersToCheck,
                                                 PrintStream error_stream)
            throws Exception {
        //TODO could also have a function that takes in different config data and places it appropriately
        //Validate the actual config file
<span class="fc" id="L156">        File configFile = checkConfigFile(configurationFileName);</span>

        //Read in the raw config file data
<span class="fc" id="L159">        List&lt;String&gt; rawConfigData = extractRawConfigurationFile(configFile);</span>

        //Validate the headers in the config file
<span class="fc" id="L162">        validateHeaders(rawConfigData, configFile, headersToCheck);</span>

        //Verify config file syntax and logic for options
<span class="fc" id="L165">        ConfigurationOptionState configOptions = null;</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (headersToCheck.contains(ConfigFileHeaderEnum.OPTION_HEADER)) {</span>
<span class="fc" id="L167">            configOptions = validateOptionLogic(validateOptionSyntax(rawConfigData, configFile), configFile);</span>
        }

        //Verify config file syntax and logic for features
<span class="fc" id="L171">        List&lt;String&gt; featuresToSave = null;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        if (headersToCheck.contains(ConfigFileHeaderEnum.FEATURE_HEADER)) {</span>
<span class="fc" id="L173">            featuresToSave = validateFeatureLogic(validateFeatureSyntax(rawConfigData, configFile), configFile);</span>
        }

        //Verify config file for invalid input files
<span class="fc" id="L177">        ConfigurationInputFiles invalidInputFiles = null;</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (headersToCheck.contains(ConfigFileHeaderEnum.INPUT_FILE_HEADER)) {</span>
<span class="fc" id="L179">            invalidInputFiles = checkForInvalidInputFiles(rawConfigData, configFile);</span>
            //Print out all invalid files to console
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">            for (File invalid : invalidInputFiles.getInvalidFiles()) {</span>
<span class="nc" id="L182">                String error_message = &quot;The &quot; + configurationFileName + &quot; configuration file refers to an invalid file path: &quot; + invalid.getAbsolutePath() + &quot;.&quot;;</span>
<span class="nc" id="L183">                UserFeedbackGenerator.printWarningMessage(error_stream, error_message);</span>
<span class="nc" id="L184">            }</span>
        }

        //Verify specified output files
<span class="fc" id="L188">        ConfigurationOutputFiles outputFiles = null;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (headersToCheck.contains(ConfigFileHeaderEnum.OUTPUT_FILE_HEADER)) {</span>
<span class="fc" id="L190">            outputFiles = checkForInvalidOutputFiles(rawConfigData, configFile);</span>
        }

<span class="fc" id="L193">        return new ConfigurationFileData(featuresToSave,</span>
                configOptions,
                outputFiles,
                configurationFileName,
                invalidInputFiles);
    }

    /**
     * Parse and validate the configuration file, assuming that all headers need to validated.
     *
     * @param configurationFileName The configuration file name that needs to be validated.
     * @param error_stream          A print stream to write errors to.
     * @return ConfigurationFileData object which contains all the appropriate data extracted and validated
     * from the specified configuration file. In this case, all jSymbolic data is specified in the
     * configuration file itself.
     * @throws Exception Thrown if configuration file is not valid.
     */
    public ConfigurationFileData parseConfigFileAllHeaders(String configurationFileName, PrintStream error_stream) throws Exception {
<span class="fc" id="L211">        return parseConfigFile(configurationFileName, Arrays.asList(ConfigFileHeaderEnum.values()), error_stream);</span>
    }

    /**
     * Parse and validate the configuration file with both all headers and, if this doesn't work, feature and
     * option headers.
     *
     * @param configurationFileName The configuration file name that needs to be validated.
     * @param error_stream          A print stream to write errors to.
     * @return ConfigurationFileData object which contains all the appropriate data extracted and validated
     * from the specified configuration file. In this case, all jSymbolic data is specified in the
     * @throws Exception Thrown if configuration file is not valid.
     */
    public ConfigurationFileData parseConfigFileAllOrFeatOpt(String configurationFileName, PrintStream error_stream)
            throws Exception {
<span class="nc" id="L226">        ConfigurationFileData configurationFileData = null;</span>

        try {
            //Try with all headers
<span class="nc" id="L230">            configurationFileData = parseConfigFileAllHeaders(configurationFileName, error_stream);</span>
<span class="nc" id="L231">        } catch (Exception ex) {</span>
            //continue
<span class="nc" id="L233">        }</span>

        //If it works then return it
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (null != configurationFileData) {</span>
<span class="nc" id="L237">            return configurationFileData;</span>
        }

        //Otherwise try with only feature and option header and return it if valid
<span class="nc" id="L241">        List&lt;ConfigFileHeaderEnum&gt; headersToCheck = Arrays.asList(ConfigFileHeaderEnum.FEATURE_HEADER, ConfigFileHeaderEnum.OPTION_HEADER);</span>
<span class="nc" id="L242">        configurationFileData = parseConfigFile(configurationFileName, headersToCheck, error_stream);</span>
<span class="nc" id="L243">        return configurationFileData;</span>
    }

    /**
     * Parse and validate the configuration file with both all headers or, if this doesn't work, all headers
     * except input files, all headers except output files and just feature and option headers.
     *
     * @param config_file_name The configuration file name that needs to be validated.
     * @param error_stream     A print stream to write errors to.
     * @return ConfigurationFileData object which contains all the appropriate data extracted and validated
     * from the specified configuration file. In this case, all jSymbolic data is specified in the
     * @throws Exception Thrown if configuration file is not valid.
     */
    public ConfigurationFileData parseConfigFileTwoThreeOrFour(String config_file_name, PrintStream error_stream)
            throws Exception {
<span class="nc" id="L258">        ConfigurationFileData configuration_file_data = null;</span>

        // Try with all four headers
        try {
<span class="nc" id="L262">            configuration_file_data = parseConfigFileAllHeaders(config_file_name, error_stream);</span>
<span class="nc" id="L263">            return configuration_file_data;</span>
<span class="nc" id="L264">        } catch (Exception e) {</span>
        }

        // Try with FEATURE_HEADER, OPTION_HEADER and INPUT_FILE_HEADER
        try {
<span class="nc" id="L269">            List&lt;ConfigFileHeaderEnum&gt; headersToCheck = Arrays.asList(ConfigFileHeaderEnum.FEATURE_HEADER, ConfigFileHeaderEnum.OPTION_HEADER, ConfigFileHeaderEnum.INPUT_FILE_HEADER);</span>
<span class="nc" id="L270">            configuration_file_data = parseConfigFile(config_file_name, headersToCheck, error_stream);</span>
<span class="nc" id="L271">            return configuration_file_data;</span>
<span class="nc" id="L272">        } catch (Exception e) {</span>
        }

        // Try with FEATURE_HEADER, OPTION_HEADER and OUTPUT_FILE_HEADER
        try {
<span class="nc" id="L277">            List&lt;ConfigFileHeaderEnum&gt; headersToCheck = Arrays.asList(ConfigFileHeaderEnum.FEATURE_HEADER, ConfigFileHeaderEnum.OPTION_HEADER, ConfigFileHeaderEnum.OUTPUT_FILE_HEADER);</span>
<span class="nc" id="L278">            configuration_file_data = parseConfigFile(config_file_name, headersToCheck, error_stream);</span>
<span class="nc" id="L279">            return configuration_file_data;</span>
<span class="nc" id="L280">        } catch (Exception e) {</span>
        }

        //Otherwise try with only FEATURE_HEADER and OPTION_HEADER, and return it if valid
<span class="nc" id="L284">        List&lt;ConfigFileHeaderEnum&gt; headersToCheck = Arrays.asList(ConfigFileHeaderEnum.FEATURE_HEADER, ConfigFileHeaderEnum.OPTION_HEADER);</span>
<span class="nc" id="L285">        configuration_file_data = parseConfigFile(config_file_name, headersToCheck, error_stream);</span>
<span class="nc" id="L286">        return configuration_file_data;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>