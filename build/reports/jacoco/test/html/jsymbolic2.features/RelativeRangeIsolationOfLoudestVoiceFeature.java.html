<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RelativeRangeIsolationOfLoudestVoiceFeature.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jSymbolic2</a> &gt; <a href="index.source.html" class="el_package">jsymbolic2.features</a> &gt; <span class="el_source">RelativeRangeIsolationOfLoudestVoiceFeature.java</span></div><h1>RelativeRangeIsolationOfLoudestVoiceFeature.java</h1><pre class="source lang-java linenums">package jsymbolic2.features;

import jsymbolic2.featureutils.Feature;
import javax.sound.midi.Sequence;
import java.util.List;
import ace.datatypes.FeatureDefinition;
import jsymbolic2.featureutils.MIDIFeatureExtractor;
import jsymbolic2.processing.MIDIIntermediateRepresentations;

/**
 * Number of pitched notes in the MIDI channel with the highest average loudness that fall outside the range
 * of any other pitched channel, divided by the total number of notes in the channel with the highest average
 * loudness. Set to 0 if there are only 0 or 1 channels containing pitched notes.
 *
 * @author Cory McKay and Tristano Tenaglia
 */
<span class="fc" id="L17">public class RelativeRangeIsolationOfLoudestVoiceFeature implements Feature {</span>

    /**
     * {@inheritDoc}
     */
    @Override()
    public String getName() {
<span class="fc" id="L24">        return &quot;Relative Range Isolation of Loudest Voice&quot;;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override()
    public String getCode() {
<span class="fc" id="L32">        return &quot;T-11&quot;;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override()
    public String getDescription() {
<span class="fc" id="L40">        return &quot;Number of pitched notes in the MIDI channel with the highest average loudness that fall outside the range of any other pitched channel, divided by the total number of notes in the channel with the highest average loudness. Set to 0 if there are only 0 or 1 channels containing pitched notes.&quot;;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override()
    public double[] extractFeature(Sequence sequence, MIDIIntermediateRepresentations sequence_info, double[][] other_feature_values) throws Exception {
        double value;
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">        if (sequence_info != null) {</span>
            // Get information from sequence_info
<span class="fc" id="L51">            int[][] channel_statistics = sequence_info.channel_statistics;</span>
<span class="fc" id="L52">            List&lt;List&lt;Integer&gt;&gt; list_of_note_on_pitches_by_channel = sequence_info.list_of_note_on_pitches_by_channel;</span>
            // Find the loudest non-Channel 10 channel
<span class="fc" id="L54">            int index_of_loudest_channel = 0;</span>
<span class="fc" id="L55">            int loudness_of_loudest_channel = 0;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">            for (int channel = 0; channel &lt; channel_statistics.length; channel++) {</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">                if (// not channel 10 (unpitched)</span>
                channel != 10 - 1) {
<span class="fc" id="L59">                    int average_loudness_this_channel = channel_statistics[channel][2];</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">                    if (average_loudness_this_channel &gt; loudness_of_loudest_channel) {</span>
<span class="fc" id="L61">                        loudness_of_loudest_channel = average_loudness_this_channel;</span>
<span class="fc" id="L62">                        index_of_loudest_channel = channel;</span>
                    }
                }
            }
            // Find the lowest and highest pitches in all channels other than 10 and the loudest channel
<span class="fc" id="L67">            boolean another_pitched_voice_exists = false;</span>
<span class="fc" id="L68">            int lowest_pitch_in_non_loudest_voice = 127;</span>
<span class="fc" id="L69">            int hightest_pitch_in_non_loudest_voice = 0;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            for (int channel = 0; channel &lt; channel_statistics.length; channel++) {</span>
<span class="fc bfc" id="L71" title="All 4 branches covered.">                if (channel != index_of_loudest_channel &amp;&amp; channel != 10 - 1) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                    if (channel_statistics[channel][0] != 0)</span>
<span class="fc" id="L73">                        another_pitched_voice_exists = true;</span>
<span class="fc" id="L74">                    int lowest_pitch_this_channel = channel_statistics[channel][4];</span>
<span class="fc" id="L75">                    int highest_pitch_this_channel = channel_statistics[channel][5];</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">                    if (lowest_pitch_this_channel &lt; lowest_pitch_in_non_loudest_voice)</span>
<span class="fc" id="L77">                        lowest_pitch_in_non_loudest_voice = lowest_pitch_this_channel;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">                    if (highest_pitch_this_channel &gt; hightest_pitch_in_non_loudest_voice)</span>
<span class="fc" id="L79">                        hightest_pitch_in_non_loudest_voice = highest_pitch_this_channel;</span>
                }
            }
            // Find number of notes in the loudest channel outside the range of any other channels
<span class="fc" id="L83">            double notes_in_loudest_channel_outside_range = 0.0;</span>
<span class="fc" id="L84">            List&lt;Integer&gt; pitches_of_notes_in_loudest_channel = list_of_note_on_pitches_by_channel.get(index_of_loudest_channel);</span>
<span class="fc bfc" id="L85" title="All 6 branches covered.">            for (Integer this_pitch : pitches_of_notes_in_loudest_channel) if (this_pitch &gt; hightest_pitch_in_non_loudest_voice || this_pitch &lt; lowest_pitch_in_non_loudest_voice)</span>
<span class="fc" id="L86">                notes_in_loudest_channel_outside_range++;</span>
            // Finalize results
<span class="fc bfc" id="L88" title="All 2 branches covered.">            if (another_pitched_voice_exists) {</span>
<span class="fc" id="L89">                double total_notes_in_loudest_voice = channel_statistics[index_of_loudest_channel][0];</span>
<span class="fc" id="L90">                value = notes_in_loudest_channel_outside_range / total_notes_in_loudest_voice;</span>
<span class="fc" id="L91">            } else</span>
<span class="fc" id="L92">                value = 0.0;</span>
<span class="fc" id="L93">        } else</span>
<span class="nc" id="L94">            value = -1.0;</span>
<span class="fc" id="L95">        double[] result = new double[1];</span>
<span class="fc" id="L96">        result[0] = value;</span>
<span class="fc" id="L97">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>