<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MIDIFeatureProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jSymbolic2</a> &gt; <a href="index.source.html" class="el_package">jsymbolic2.processing</a> &gt; <span class="el_source">MIDIFeatureProcessor.java</span></div><h1>MIDIFeatureProcessor.java</h1><pre class="source lang-java linenums">package jsymbolic2.processing;

import ace.datatypes.DataBoard;
import ace.datatypes.DataSet;
import ace.datatypes.FeatureDefinition;
import jsymbolic2.featureutils.Feature;
import jsymbolic2.featureutils.FeatureExtractorAccess;
import jsymbolic2.featureutils.MEIFeatureExtractor;
import jsymbolic2.featureutils.MIDIFeatureExtractor;
import mckay.utilities.sound.midi.MIDIMethods;
import org.apache.commons.lang3.ArrayUtils;
import org.ddmal.jmei2midi.meielements.meispecific.MeiSpecificStorage;

import javax.sound.midi.Sequence;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;


/**
 * This class is used to pre-process and extract features from MIDI recordings.
 * An object of this class should be instantiated with parameters indicating
 * the details of how features are to be extracted.
 *
 * &lt;p&gt;The extractFeatures method should be called whenever recordings are
 * available to be analyzed. This method should be called once for each
 * recording. It will generate DataSet for each recording and add it in List of DataSets
 *
 * &lt;p&gt;When you finish with pocessing the records, call generateDataBoard to get DataBoard
 * that contains all DataSets.
 *
 * &lt;p&gt;Features are extracted for each window and, when appropriate, the average
 * and standard deviation of each of these features is extracted for each
 * recording.
 *
 * @author Cory McKay and Tristano Tenaglia
 */
public class MIDIFeatureProcessor {
    /* FIELDS ****************************************************************/

    /**
     * The window size in seconds used for dividing up the recordings to
     * classify.
     */
    private final double windowSize;

    /**
     * The number of seconds that windows are offset by. A value of zero means
     * that there is no window overlap.
     */
    private final double windowOverlapOffset;

    /**
     * The features that are to be extracted (including dependencies of features to be saved, not just the
     * features to be saved themselves).
     */
    private Feature[] midiFeatureExtractors;

    /**
     * The dependencies of the features in the feature_extractors field.
     * The first indice corresponds to the feature_extractors indice
     * and the second identifies the number of the dependent feature.
     * The entry identifies the indice of the feature in feature_extractors
     * that corresponds to a dependant feature. The first dimension will be
     * null if there are no dependent features.
     */
    private int[][] featureExtractorDependencies;

    /**
     * The longest number of windows of previous features that each feature
     * must have before it can be extracted. The indice corresponds to that of
     * feature_extractors.
     */
    private int[] maxFeatureOffsets;

    /**
     * Which features are to be saved after processing. Entries correspond to
     * the feature_extractors field.
     */
    private boolean[] featuresToSaveMask;

    /**
     * Whether or not to save features individually for each window.
     */
    private final boolean saveFeaturesForEachWindow;

    /**
     * Whether or not to save the average and standard deviation of each
     * feature across all windows.
     */
    private final boolean saveOverallRecordingFeatures;

    /**
     * List of DataSets. Each DataSet corresponds to record that was processed.
     */
<span class="fc" id="L97">    private final List&lt;DataSet&gt; dataSets = new ArrayList&lt;&gt;();</span>

    /**
     * Array of overall FeatureDefinitions.
     */
    private final FeatureDefinition[] overallFeatureDefinitions;

    /**
     * Array of FeatureDefinitions of extractors.
     */
    private final FeatureDefinition[] featureExtractorsDefinitions;

    /**
     * Array of overall FeatureDefinitions' names.
     */
    private final String[] overallFeatureNames;

    /**
     * Array of extractors' FeatureDefinitions names.
     */
    private final String[] featureExtractorsNames;

    /* CONSTRUCTORS **********************************************************/

    /**
     * Validates and stores the configuration to use for extracting features
     * from MIDI recordings.
     * &lt;p&gt;
     * meaning no overlap.
     *
     * @param allFeatureExtractors         All features that can be
     *                                     extracted.
     * @param featuresToSaveAmongAll       Which features are to be
     *                                     saved. Entries correspond to
     *                                     the allFeatureExtractors
     *                                     parameter.
     * @param saveOverallRecordingFeatures Whetehr or not to save the
     *                                     average and standard deviation
     *                                     of each feature across all
     *                                     windows.
     * @throws Exception Throws an informative
     *                   exception if the input
     *                   parameters are invalid, including if any of the feature
     *                   in allFeatureExtractors have dependencies that do not
     *                   exist in allFeatureExtractors.
     */
    public MIDIFeatureProcessor(WindowInfo windowInfo,
                                Feature[] allFeatureExtractors,
                                boolean[] featuresToSaveAmongAll,
<span class="fc" id="L146">                                boolean saveOverallRecordingFeatures) throws Exception {</span>
<span class="fc" id="L147">        checkWindowFlags(windowInfo.window_size(), windowInfo.window_overlap(), windowInfo.save_features_for_each_window(), saveOverallRecordingFeatures);</span>
<span class="fc" id="L148">        checkAtLeastOneFlagToSaveWasSelected(featuresToSaveAmongAll);</span>
<span class="fc" id="L149">        checkExtractors(allFeatureExtractors);</span>
        // Save parameters as fields
<span class="fc" id="L151">        this.windowSize = windowInfo.window_size();</span>
<span class="fc" id="L152">        this.saveFeaturesForEachWindow = windowInfo.save_features_for_each_window();</span>
<span class="fc" id="L153">        this.saveOverallRecordingFeatures = saveOverallRecordingFeatures;</span>

        // Calculate the window offset
<span class="fc" id="L156">        windowOverlapOffset = windowInfo.window_overlap() * windowSize;</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (windowOverlapOffset &gt; windowSize)</span>
<span class="nc" id="L158">            throw new Exception(&quot;Window overlap offset is greater than window size, this is not possible.&quot;);</span>
        // Find which features need to be extracted and in what order. Also find
        // the indices of dependencies and the maximum offsets for each feature.
<span class="fc" id="L161">        findAndOrderFeaturesToExtract(allFeatureExtractors, featuresToSaveAmongAll);</span>

<span class="fc" id="L163">        featureExtractorsDefinitions = new FeatureDefinition[allFeatureExtractors.length];</span>
<span class="fc" id="L164">        featureExtractorsNames = new String[allFeatureExtractors.length];</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (int feat = 0; feat &lt; featureExtractorsDefinitions.length; ++feat) {</span>
<span class="fc" id="L166">            featureExtractorsDefinitions[feat] = allFeatureExtractors[feat].getFeatureDefinition();</span>
<span class="fc" id="L167">            featureExtractorsNames[feat] = featureExtractorsDefinitions[feat].name;</span>
        }
<span class="fc" id="L169">        overallFeatureDefinitions = generateOverallFeatureDefinitions();</span>
<span class="fc" id="L170">        overallFeatureNames = new String[overallFeatureDefinitions.length];</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (int feat = 0; feat &lt; overallFeatureDefinitions.length; ++feat) {</span>
<span class="fc" id="L172">            overallFeatureNames[feat] = overallFeatureDefinitions[feat].name;</span>
        }
<span class="fc" id="L174">    }</span>

    private void checkExtractors(Feature[] allFeatureExtractors) throws Exception {
        // Verify that feature names referred to by all dependencies actually exist.
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (Feature featureExtractor : allFeatureExtractors) {</span>
<span class="fc" id="L179">            String[] thisFeatureDependencies = featureExtractor.getDependencies();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (thisFeatureDependencies == null) {</span>
<span class="fc" id="L181">                continue;</span>
            }
<span class="fc" id="L183">            boolean foundDependency = false;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            for (String dependency : thisFeatureDependencies) {</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                for (int i = 0; i &lt; allFeatureExtractors.length; i++) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    if (dependency.equals(allFeatureExtractors[i].getFeatureDefinition().name)) {</span>
                        {
<span class="fc" id="L188">                            foundDependency = true;</span>
<span class="fc" id="L189">                            break;</span>
                        }
                    }
                }
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (!foundDependency) {</span>
<span class="nc" id="L194">                    throw new Exception(&quot;The &quot; +</span>
<span class="nc" id="L195">                            featureExtractor.getFeatureDefinition().name +</span>
                            &quot; feature needs the &quot; + dependency +
                            &quot; feature in order to be calculated, yet no feature with the latter name could be found.&quot;);
                }
            }
        }
<span class="fc" id="L201">    }</span>

    private void checkAtLeastOneFlagToSaveWasSelected(boolean[] featuresToSaveAmongAll) throws Exception {
<span class="fc" id="L204">        boolean one_selected = false;</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        for (boolean featureToSaveFlag : featuresToSaveAmongAll) {</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (featureToSaveFlag) {</span>
<span class="fc" id="L207">                one_selected = true;</span>
<span class="fc" id="L208">                break;</span>
            }
        }
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (!one_selected) {</span>
<span class="nc" id="L212">            throw new Exception(&quot;No features have been set to be saved.&quot;);</span>
        }
<span class="fc" id="L214">    }</span>

    private void checkWindowFlags(double windowSize, double windowOverlap, boolean saveFeaturesForEachWindow, boolean saveOverallRecordingFeatures) throws Exception {
        // Throw an exception if the control parameters are invalid
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">        if (!saveFeaturesForEachWindow &amp;&amp; !saveOverallRecordingFeatures)</span>
<span class="nc" id="L219">            throw new Exception(&quot;&quot;&quot;</span>
                    You must save at least one of the windows-based
                    features and the overall file-based features if
                    windows are to be used.&quot;&quot;&quot;);
<span class="pc bpc" id="L223" title="2 of 4 branches missed.">        if (windowOverlap &lt; 0.0 || windowOverlap &gt;= 1.0)</span>
<span class="nc" id="L224">            throw new Exception(&quot;&quot;&quot;</span>
                    Window overlap fraction is %s.
<span class="nc" id="L226">                    This value must be 0.0 or above and less than 1.0.&quot;&quot;&quot;.formatted(windowOverlap));</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (windowSize &lt; 0.0)</span>
<span class="nc" id="L228">            throw new Exception(&quot;&quot;&quot;</span>
                    Window size is %s.
<span class="nc" id="L230">                    This value must be at or above 0.0 seconds.&quot;&quot;&quot;.formatted(windowSize));</span>
<span class="fc" id="L231">    }</span>

    /*PUBLIC METHODS ********************************************************/

    /**
     * @return The features that are to be extracted (including dependencies of features to be saved, not
     * just the features to be saved themselves).
     */
    public Feature[] getFinalFeaturesToBeExtracted() {
<span class="nc" id="L240">        return midiFeatureExtractors;</span>
    }

    /**
     * @return True if it has features for MEI files.
     */
    public boolean containsMeiFeatures() {
<span class="fc" id="L247">        List&lt;String&gt; all_mei_specific_features = FeatureExtractorAccess.getNamesOfMeiSpecificFeatures();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (Feature feature : midiFeatureExtractors) {</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (all_mei_specific_features.contains(feature.getFeatureDefinition().name)) {</span>
<span class="nc" id="L250">                return true;</span>
            }
        }
<span class="fc" id="L253">        return false;</span>
    }

    /**
     * Extract the features from the provided MeiSequence.
     *
     * @param name               How to name sequence in DataBoard.
     * @param sequence
     * @param meiSpecificStorage
     * @throws Exception When an unforeseen runtime exception occurs.
     */
    public void extractFeaturesFromSequence(String name, Sequence sequence, MeiSpecificStorage meiSpecificStorage)
            throws Exception {
        // Extract the data from the file and check for exceptions
        // Prepare the windows for feature extraction with correct times
        // Tick arrays have been added to account for multiple windows
<span class="fc" id="L269">        double[] secondsPerTick = MIDIMethods.getSecondsPerTick(sequence);</span>
        int[] startTicks;
        int[] endTicks;
        Sequence[] windows;
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (!saveFeaturesForEachWindow) {</span>
<span class="fc" id="L274">            List&lt;int[]&gt; startEndTickArrays = MIDIMethods.getStartEndTickArrays(sequence, sequence.getMicrosecondLength() / 1000000.0, 0.0, secondsPerTick);</span>
<span class="fc" id="L275">            startTicks = startEndTickArrays.get(0);</span>
<span class="fc" id="L276">            endTicks = startEndTickArrays.get(1);</span>
<span class="fc" id="L277">            windows = new Sequence[1];</span>
<span class="fc" id="L278">            windows[0] = sequence;</span>
<span class="fc" id="L279">        } else {</span>
<span class="fc" id="L280">            List&lt;int[]&gt; startEndTickArrays = MIDIMethods.getStartEndTickArrays(sequence, windowSize, windowOverlapOffset, secondsPerTick);</span>
<span class="fc" id="L281">            startTicks = startEndTickArrays.get(0);</span>
<span class="fc" id="L282">            endTicks = startEndTickArrays.get(1);</span>
<span class="fc" id="L283">            windows = MIDIMethods.breakSequenceIntoWindows(sequence, windowSize, windowOverlapOffset, startTicks, endTicks);</span>
        }
        //Mei Specific Storage added here and null is set if the file is not an mei file
        // Extract the feature values from the samples
<span class="fc" id="L287">        double[][][] windowFeatureValues = getFeatures(windows, meiSpecificStorage);</span>
        // Find the feature averages and standard deviations if appropriate
<span class="fc" id="L289">        double[][] overallFeatureValues = null;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (saveOverallRecordingFeatures) {</span>
<span class="fc" id="L291">            overallFeatureValues = generateOverallRecordingFeatures(windowFeatureValues);</span>
        }
<span class="fc" id="L293">        addDataSet(windowFeatureValues, name, overallFeatureValues, startTicks, endTicks, secondsPerTick);</span>
<span class="fc" id="L294">    }</span>

    /**
     * Extracts features from each window of the given MIDI sequences. If the
     * passed windows parameter consists of only one window, then this could
     * be a whole unwindowed MIDI file.
     *
     * @param meiSpecificStorage The mei specific data storage used to extract
     *                           mei specific features from the sequence windows.
     *                           This will be null if the file is not an mei file
     *                           and otherwise it will contain all mei specific data
     *                           extracted by jMei2Midi.
     * @param windows            The ordered MIDI windows to extract features from.
     * @return The extracted feature values for this recording.
     * The first indice identifies the window, the second
     * identifies the feature and the third identifies
     * the feature value. The third dimension will be
     * null if the given feature could not be extracted
     * for the given window.
     * @throws Exception Throws an exception if a problem occurs.
     */
    public double[][][] getFeatures(Sequence[] windows, MeiSpecificStorage meiSpecificStorage) throws Exception {
        // The extracted feature values for this recording. The first indice
        // identifies the window, the second identifies the feature and the
        // third identifies the feature value.
<span class="fc" id="L319">        double[][][] results = new double[windows.length][midiFeatureExtractors.length][];</span>

        // Extract features from each window one by one and add save the results.
        // The last window is zero-padded at the end if it falls off the edge of the
        // provided samples.
<span class="fc bfc" id="L324" title="All 2 branches covered.">        for (int win = 0; win &lt; windows.length; win++) {</span>
            // Extract information from sequence that is needed to extract features
<span class="fc" id="L326">            MIDIIntermediateRepresentations intermediate = new MIDIIntermediateRepresentations(windows[win]);</span>

            // Extract the features one by one
<span class="fc bfc" id="L329" title="All 2 branches covered.">            for (int feat = 0; feat &lt; midiFeatureExtractors.length; feat++) {</span>
<span class="fc" id="L330">                processFeature(windows, meiSpecificStorage, results, win, intermediate, feat);</span>
            }
        }

//        for (int win = 0; win &lt; results.length; ++win) {
//            for (int feat = 0; feat &lt; midiFeatureExtractors.length; ++feat) {
//                if (!featuresToSaveMask[feat]) {
//                    results[win][feat] = null;
//                }
//            }
//        }
        // Return the results
<span class="fc" id="L342">        return results;</span>
    }

    private void processFeature(Sequence[] windows, MeiSpecificStorage meiSpecificStorage, double[][][] results, int win, MIDIIntermediateRepresentations intermediate, int feat) throws Exception {
        // Only extract this feature if enough previous information
        // is available to extract this feature
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (win &gt;= maxFeatureOffsets[feat]) {</span>
            // Find the correct feature
<span class="fc" id="L350">            Feature feature = midiFeatureExtractors[feat];</span>

<span class="fc" id="L352">            double[][] otherFeatureValues = findPreviousExtractedFeatures(results, win, feat, feature);</span>

            //Check here if the file is an MEI file and if the feature is an MEI feature
            //Otherwise just extract the midi feature data
<span class="pc bpc" id="L356" title="1 of 4 branches missed.">            if (meiSpecificStorage == null &amp;&amp; feature instanceof MEIFeatureExtractor) {</span>
                //Skip if this is a non-mei file as mei features are not valid
<span class="nc" id="L358">                return;</span>
            }
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">            if (meiSpecificStorage != null &amp;&amp; feature instanceof MEIFeatureExtractor) {</span>
<span class="nc" id="L361">                results[win][feat] = ((MEIFeatureExtractor) feature).extractMEIFeature(meiSpecificStorage, windows[win], intermediate, otherFeatureValues);</span>
<span class="nc" id="L362">                return;</span>
            }
            // Store the extracted feature values
<span class="fc" id="L365">            results[win][feat] = feature.extractFeature(windows[win], intermediate, otherFeatureValues);</span>
<span class="fc" id="L366">            return;</span>
        }
<span class="nc" id="L368">        results[win][feat] = null;</span>
<span class="nc" id="L369">    }</span>

    /**
     * Find previously extracted feature values that this feature needs
     *
     * @param results
     * @param win
     * @param feat
     * @param feature
     * @return
     */
    private double[][] findPreviousExtractedFeatures(double[][][] results, int win, int feat, Feature feature) {
<span class="fc" id="L381">        double[][] otherFeatureValues = null;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (featureExtractorDependencies[feat] != null) {</span>
<span class="fc" id="L383">            otherFeatureValues = new double[featureExtractorDependencies[feat].length][];</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (int i = 0; i &lt; featureExtractorDependencies[feat].length; i++) {</span>
<span class="fc" id="L385">                int featureIndice = featureExtractorDependencies[feat][i];</span>
                /* TODO Check if this is a correct bug fix */
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                if (feature.getDependencyOffsets() == null) {</span>
<span class="fc" id="L388">                    otherFeatureValues[i] = results[win][featureIndice];</span>
                } else {
<span class="nc" id="L390">                    int offset = feature.getDependencyOffsets()[i];</span>
<span class="nc" id="L391">                    otherFeatureValues[i] = results[win + offset][featureIndice];</span>
                }
            }
        }
<span class="fc" id="L395">        return otherFeatureValues;</span>
    }

    /**
     * Generates DataBoard based in list of DataSets that were constructed during features extractions
     *
     * @return DataBoard of processed recordings
     * @throws Exception Throws an exception if it cannot create DataBoard object.
     */
    public DataBoard generateDataBoard() throws Exception {
<span class="fc" id="L405">        DataBoard dataBoard = new DataBoard(null, null, dataSets.toArray(new DataSet[0]), null);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (saveOverallRecordingFeatures) {</span>
<span class="fc" id="L407">            dataBoard.feature_definitions = IntStream.range(0, featureExtractorsDefinitions.length)</span>
<span class="fc" id="L408">                    .filter(i -&gt; featuresToSaveMask[i])</span>
<span class="fc" id="L409">                    .mapToObj(i -&gt; featureExtractorsDefinitions[i])</span>
<span class="fc" id="L410">                    .toArray(FeatureDefinition[]::new);</span>
        } else {
<span class="fc" id="L412">            dataBoard.feature_definitions = IntStream.range(0, featureExtractorsDefinitions.length)</span>
<span class="fc" id="L413">                    .filter(i -&gt; featuresToSaveMask[i])</span>
<span class="fc" id="L414">                    .mapToObj(i -&gt; featureExtractorsDefinitions[i])</span>
<span class="fc" id="L415">                    .toArray(FeatureDefinition[]::new);</span>
        }
<span class="fc" id="L417">        return dataBoard;</span>
    }

    /* PRIVATE METHODS *******************************************************/

    /**
     * Fills the feature_extractors, feature_extractor_dependencies,
     * max_feature_offsets and features_to_save fields. This involves finding
     * which features need to be extracted and in what order and finding
     * the indices of dependencies and the maximum offsets for each feature.
     *
     * @param allFeatureExtractors   All features that can be extracted.
     * @param featuresToSaveAmongAll Which features are to be saved.
     *                               Entries correspond to the
     *                               allFeatureExtractors parameter.
     */
    private void findAndOrderFeaturesToExtract(Feature[] allFeatureExtractors,
                                               boolean[] featuresToSaveAmongAll) {
<span class="fc" id="L435">        String[] allFeatureNames = getAllFeatureNames(allFeatureExtractors);</span>
<span class="fc" id="L436">        String[][] dependencies = getDependencies(allFeatureExtractors, featuresToSaveAmongAll);</span>
        // Start off the array of which features to extract by making sure to extract all those features
        // whose values are marked to be saved.
<span class="fc" id="L439">        boolean[] featuresToExtractIncludingDependencies = new boolean[allFeatureExtractors.length];</span>
<span class="fc" id="L440">        System.arraycopy(featuresToSaveAmongAll, 0, featuresToExtractIncludingDependencies,</span>
                0, allFeatureExtractors.length);
<span class="fc" id="L442">        updateExtraDependencies(allFeatureExtractors, allFeatureNames, dependencies, featuresToExtractIncludingDependencies);</span>
<span class="fc" id="L443">        orderFeaturesToExtract(allFeatureExtractors, featuresToSaveAmongAll, allFeatureNames, dependencies, featuresToExtractIncludingDependencies);</span>
<span class="fc" id="L444">        prepareIndicies();</span>
<span class="fc" id="L445">        setMaxOffset();</span>
<span class="fc" id="L446">    }</span>

    /**
     * Begin the process of finding the correct order to extract features in by filling the
     * feature_extractors field with all features that are to be extracted (i.e. the combination of
     * those features whose values are marked to be saved and those features that are needed in order
     * to calculate those features marked to be saved). The ordering consists of the originally
     * specified feature order, with dependent features added in before they are needed.
     * Also note which of these have values that are actually to be saved by filling in
     * features_to_save.
     *
     * @param allFeatureExtractors
     * @param featuresToSaveAmongAll
     * @param allFeatureNames
     * @param dependencies
     * @param featuresToExtractIncludingDependencies
     */
    private void orderFeaturesToExtract(Feature[] allFeatureExtractors, boolean[] featuresToSaveAmongAll, String[] allFeatureNames, String[][] dependencies, boolean[] featuresToExtractIncludingDependencies) {
<span class="fc" id="L464">        int numberFeaturesToExtract = 0;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        for (int i = 0; i &lt; featuresToExtractIncludingDependencies.length; i++)</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (featuresToExtractIncludingDependencies[i]) numberFeaturesToExtract++;</span>
<span class="fc" id="L467">        midiFeatureExtractors = new Feature[numberFeaturesToExtract];</span>
<span class="fc" id="L468">        featuresToSaveMask = featuresToSaveAmongAll;</span>
<span class="fc" id="L469">        boolean[] featureAdded = new boolean[allFeatureExtractors.length];</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        for (int i = 0; i &lt; featureAdded.length; i++)</span>
<span class="fc" id="L471">            featureAdded[i] = false;</span>
<span class="fc" id="L472">        int currentPosition = 0;</span>
<span class="fc" id="L473">        boolean inProcess = true;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">        while (inProcess) {</span>
<span class="fc" id="L475">            inProcess = false;</span>

            // Add all features that have no remaining dependencies and remove
            // their dependencies from all unadded features
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (int feat = 0; feat &lt; allFeatureExtractors.length; feat++) {</span>
<span class="fc bfc" id="L480" title="All 4 branches covered.">                if (featuresToExtractIncludingDependencies[feat] &amp;&amp; !featureAdded[feat]) {</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                    if (dependencies[feat] == null) // add feature if it has no dependencies</span>
                    {
<span class="fc" id="L483">                        featureAdded[feat] = true;</span>
<span class="fc" id="L484">                        midiFeatureExtractors[currentPosition] = allFeatureExtractors[feat];</span>
<span class="fc" id="L485">                        currentPosition++;</span>
<span class="fc" id="L486">                        inProcess = true;</span>
<span class="fc" id="L487">                        removeDependency(allFeatureExtractors, allFeatureNames, dependencies, featuresToExtractIncludingDependencies, feat);</span>
                    }
                }
            }
        }
<span class="fc" id="L492">    }</span>

    /**
     * Remove this dependency from all features that have
     * it as a dependency and are marked to be extracted
     *
     * @param allFeatureExtractors
     * @param allFeatureNames
     * @param dependencies
     * @param featuresToExtractIncludingDependencies
     * @param feat
     */
    private void removeDependency(Feature[] allFeatureExtractors, String[] allFeatureNames, String[][] dependencies, boolean[] featuresToExtractIncludingDependencies, int feat) {
<span class="fc bfc" id="L505" title="All 2 branches covered.">        for (int i = 0; i &lt; allFeatureExtractors.length; i++) {</span>
<span class="fc bfc" id="L506" title="All 4 branches covered.">            if (featuresToExtractIncludingDependencies[i] &amp;&amp; dependencies[i] != null) {</span>
<span class="fc" id="L507">                int numDefs = dependencies[i].length;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">                for (int j = 0; j &lt; numDefs; j++) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                    if (dependencies[i][j].equals(allFeatureNames[feat])) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">                        if (dependencies[i].length == 1) {</span>
<span class="fc" id="L511">                            dependencies[i] = null;</span>
<span class="fc" id="L512">                            j = numDefs;</span>
                        } else {
<span class="fc" id="L514">                            String[] temp = new String[dependencies[i].length - 1];</span>
<span class="fc" id="L515">                            int m = 0;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                            for (int k = 0; k &lt; dependencies[i].length; k++) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                                if (k != j) {</span>
<span class="fc" id="L518">                                    temp[m] = dependencies[i][k];</span>
<span class="fc" id="L519">                                    m++;</span>
                                }
                            }
<span class="fc" id="L522">                            dependencies[i] = temp;</span>
<span class="fc" id="L523">                            j--;</span>
<span class="fc" id="L524">                            numDefs--;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L530">    }</span>

    /**
     * Update featuresToExtractIncludingDependencies to ALSO include those features that are not
     * marked to be saved, but are needed as dependencies in order to calculate features that are
     * marked to be saved. Also update dependencies to include any new dependencies that are introduced
     * by scheduling new features to be extracted because they themselves are dependencies of other
     * features.
     *
     * @param allFeatureExtractors
     * @param allFeatureNames
     * @param dependencies
     * @param featuresToExtractIncludingDependencies
     */
    private void updateExtraDependencies(Feature[] allFeatureExtractors, String[] allFeatureNames, String[][] dependencies, boolean[] featuresToExtractIncludingDependencies) {
<span class="fc" id="L545">        boolean done = false;</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        while (!done) {</span>
<span class="fc" id="L547">            done = true;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (int feat = 0; feat &lt; allFeatureExtractors.length; feat++) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (dependencies[feat] != null) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">                    for (int dep = 0; dep &lt; dependencies[feat].length; dep++) {</span>
<span class="fc" id="L551">                        String thisDependencyName = dependencies[feat][dep];</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">                        for (int j = 0; j &lt; allFeatureExtractors.length; j++) {</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                            if (thisDependencyName.equals(allFeatureNames[j])) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">                                if (!featuresToExtractIncludingDependencies[j]) {</span>
<span class="nc" id="L555">                                    featuresToExtractIncludingDependencies[j] = true;</span>
<span class="nc" id="L556">                                    dependencies[j] = allFeatureExtractors[j].getDependencies();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                                    if (dependencies[j] != null) done = false;</span>
                                }
<span class="fc" id="L559">                                j = allFeatureExtractors.length;</span>
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L566">    }</span>

    /**
     * Find the indices of the feature extractor dependencies for each feature extractor
     */
    private void prepareIndicies() {
<span class="fc" id="L572">        featureExtractorDependencies = new int[midiFeatureExtractors.length][];</span>
<span class="fc" id="L573">        String[] feature_names = new String[midiFeatureExtractors.length];</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        for (int feat = 0; feat &lt; feature_names.length; feat++)</span>
<span class="fc" id="L575">            feature_names[feat] = midiFeatureExtractors[feat].getFeatureDefinition().name;</span>
<span class="fc" id="L576">        String[][] featureDependenciesStr = new String[midiFeatureExtractors.length][];</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (int feat = 0; feat &lt; featureDependenciesStr.length; feat++)</span>
<span class="fc" id="L578">            featureDependenciesStr[feat] = midiFeatureExtractors[feat].getDependencies();</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">        for (int i = 0; i &lt; featureDependenciesStr.length; i++)</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (featureDependenciesStr[i] != null) {</span>
<span class="fc" id="L581">                featureExtractorDependencies[i] = new int[featureDependenciesStr[i].length];</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">                for (int j = 0; j &lt; featureDependenciesStr[i].length; j++)</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                    for (int k = 0; k &lt; feature_names.length; k++)</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">                        if (featureDependenciesStr[i][j].equals(feature_names[k]))</span>
<span class="fc" id="L585">                            featureExtractorDependencies[i][j] = k;</span>
            }
<span class="fc" id="L587">    }</span>

    /**
     * Find the maximum offset for each feature
     */
    private void setMaxOffset() {
<span class="fc" id="L593">        maxFeatureOffsets = new int[midiFeatureExtractors.length];</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int feat = 0; feat &lt; maxFeatureOffsets.length; feat++) {</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            if (midiFeatureExtractors[feat].getDependencyOffsets() == null) {</span>
<span class="fc" id="L596">                maxFeatureOffsets[feat] = 0;</span>
<span class="fc" id="L597">                continue;</span>
            }
<span class="nc" id="L599">            int[] offsetsOfCurrentFeature = midiFeatureExtractors[feat].getDependencyOffsets();</span>
<span class="nc" id="L600">            maxFeatureOffsets[feat] = Math.abs(offsetsOfCurrentFeature[0]);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            for (int offsetOfCurrentFeature : offsetsOfCurrentFeature) {</span>
<span class="nc" id="L602">                maxFeatureOffsets[feat] = Math.max(Math.abs(offsetOfCurrentFeature), offsetOfCurrentFeature);</span>
            }
        }
<span class="fc" id="L605">    }</span>

    /**
     * Find the dependencies of each feature marked to be extracted.
     * Mark an entry as null if that entry's matching feature is not set to be extracted.
     * Note that an entry will also be null if the corresponding feature has no dependencies.
     *
     * @param allFeatureExtractors
     * @param featuresToSaveAmongAll
     * @return
     */
    private String[][] getDependencies(Feature[] allFeatureExtractors, boolean[] featuresToSaveAmongAll) {
<span class="fc" id="L617">        String[][] dependencies = new String[allFeatureExtractors.length][];</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        for (int feat = 0; feat &lt; allFeatureExtractors.length; feat++) {</span>
<span class="fc" id="L619">            dependencies[feat] = null;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">            if (featuresToSaveAmongAll[feat]) dependencies[feat] = allFeatureExtractors[feat].getDependencies();</span>
        }
<span class="fc" id="L622">        return dependencies;</span>
    }

    /**
     * Find the names of all features
     *
     * @param allFeatureExtractors
     * @return
     */
    private String[] getAllFeatureNames(Feature[] allFeatureExtractors) {
<span class="fc" id="L632">        String[] allFeatureNames = new String[allFeatureExtractors.length];</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int feat = 0; feat &lt; allFeatureExtractors.length; feat++)</span>
<span class="fc" id="L634">            allFeatureNames[feat] = allFeatureExtractors[feat].getFeatureDefinition().name;</span>
<span class="fc" id="L635">        return allFeatureNames;</span>
    }


    /**
     * Calculates the averages and standard deviations over a whole recording
     * of each of the windows-based features. Generates a feature definition
     * for each such feature. If only one value is present (dep.e. only one
     * window) then this value is stored without any standard deviation.
     *
     * @param windowFeatureValues The extracted window feature values
     *                            for this recording. The first
     *                            indice identifies the window, the
     *                            second identifies the feature and
     *                            the third identifies the feature
     *                            value. The third dimension will
     *                            be null if the given feature could
     *                            not be extracted for the given
     *                            window.
     * @return The extracted overall average and
     * standard deviations of the window
     * feature values that were passed to
     * this method. The first indice
     * identifies the feature and the
     * second identifies the feature
     * value. The order of the features
     * correspond to the
     * FeatureDefinitions that the
     * overallFeatureDefinitions
     * parameter is filled with.
     */
    private double[][] generateOverallRecordingFeatures(double[][][] windowFeatureValues) {
        double[][] featureOverallValues;
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">        if (windowFeatureValues.length == 1) {</span>
<span class="fc" id="L669">            featureOverallValues = windowFeatureValues[0];</span>
<span class="fc" id="L670">            return featureOverallValues;</span>
        }
<span class="nc" id="L672">        featureOverallValues = new double[midiFeatureExtractors.length * 2][];</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        for (int feat = 0; feat &lt; midiFeatureExtractors.length; feat++) {</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">            if (windowFeatureValues[windowFeatureValues.length - 1][feat] == null || !featuresToSaveMask[feat]) {</span>
<span class="nc" id="L675">                featureOverallValues[2 * feat] = null;</span>
<span class="nc" id="L676">                featureOverallValues[2 * feat + 1] = null;</span>
<span class="nc" id="L677">                continue;</span>
            }
            // Find the averages and standard deviations
<span class="nc" id="L680">            double[] averages = new double[windowFeatureValues[windowFeatureValues.length - 1][feat].length];</span>
<span class="nc" id="L681">            double[] stdvs = new double[windowFeatureValues[windowFeatureValues.length - 1][feat].length];</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            for (int val = 0; val &lt; windowFeatureValues[windowFeatureValues.length - 1][feat].length; val++) {</span>
                // Find the number of windows that have featureOverallValues for this value feature
<span class="nc" id="L684">                int count = 0;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                for (double[][] windowFeaturesValues : windowFeatureValues) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                    if (windowFeaturesValues[feat] != null) count++;</span>
                }

                // Find the featureOverallValues to find the average and standard deviations of
<span class="nc" id="L690">                double[] valuesToProcess = new double[count];</span>
<span class="nc" id="L691">                int current = 0;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                for (double[][] windowFeaturesValues : windowFeatureValues)</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                    if (windowFeaturesValues[feat] != null) {</span>
<span class="nc" id="L694">                        valuesToProcess[current] = windowFeaturesValues[feat][val];</span>
<span class="nc" id="L695">                        current++;</span>
                    }
                // Calculate the averages and standard deviations
<span class="nc" id="L698">                averages[val] = mckay.utilities.staticlibraries.MathAndStatsMethods.getAverage(valuesToProcess);</span>
<span class="nc" id="L699">                stdvs[val] = mckay.utilities.staticlibraries.MathAndStatsMethods.getStandardDeviation(valuesToProcess);</span>
            }
            // Store the results
<span class="nc" id="L702">            featureOverallValues[2 * feat] = averages;</span>
<span class="nc" id="L703">            featureOverallValues[2 * feat + 1] = stdvs;</span>
        }
<span class="nc" id="L705">        return featureOverallValues;</span>
    }

    /**
     * Generates FeatureDefinitions for overall features
     *
     * @return array of overall FeatureDefinitions
     */
    private FeatureDefinition[] generateOverallFeatureDefinitions() {
<span class="fc" id="L714">        FeatureDefinition[] definitions = new FeatureDefinition[midiFeatureExtractors.length * 2];</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">        for (int feat = 0; feat &lt; midiFeatureExtractors.length; feat++) {</span>
            // Make the definitions
<span class="fc" id="L717">            FeatureDefinition thisDef = midiFeatureExtractors[feat].getFeatureDefinition();</span>
<span class="fc" id="L718">            FeatureDefinition averageDefinition = new FeatureDefinition(thisDef.name + &quot; Overall Average&quot;, thisDef.description + &quot;\nThis is the overall average over all windows.&quot;, thisDef.is_sequential, thisDef.dimensions);</span>
<span class="fc" id="L719">            FeatureDefinition stdvDefinition = new FeatureDefinition(thisDef.name + &quot; Overall Standard Deviation&quot;, thisDef.description + &quot;\nThis is the overall standard deviation over all windows.&quot;, thisDef.is_sequential, thisDef.dimensions);</span>
            // Store the results
<span class="fc" id="L721">            definitions[2 * feat] = averageDefinition;</span>
<span class="fc" id="L722">            definitions[2 * feat + 1] = stdvDefinition;</span>
        }
        // Finalize the values
<span class="fc" id="L725">        return definitions;</span>
    }

    /**
     * Generates DataSet for current recording and adds it in list of DataSets
     *
     * @param windowFeatureValues  The extracted window feature values
     *                             for this recording. The first
     *                             indice identifies the window, the
     *                             second identifies the feature and
     *                             the third identifies the feature
     *                             value. The third dimension will
     *                             be null if the given feature could
     *                             not be extracted for the given
     *                             window.
     * @param overallFeatureValues The extracted overall average and
     *                             standard deviations of the window
     *                             feature values. The first indice
     *                             identifies the feature and the
     *                             second identifies the feature
     *                             value. The order of the features
     *                             correspond to the
     *                             overall_feature_definitions
     *                             parameter. This value is null if
     *                             overall feature values were not
     *                             extracted.
     * @param startTicks           The start ticks that correspond to each MIDI window.
     * @param endTicks             The end ticks that correspond to each MIDI window.
     * @param secondsPerTick       The number of seconds in a MIDI tick given by the sequence.
     */
    private void addDataSet(double[][][] windowFeatureValues, String identifier,
                            double[][] overallFeatureValues,
                            int[] startTicks,
                            int[] endTicks,
                            double[] secondsPerTick) {
<span class="fc" id="L760">        DataSet rootDataSet = new DataSet(identifier, null, Double.NaN, Double.NaN,</span>
                null, null, null);
<span class="fc bfc" id="L762" title="All 2 branches covered.">        if (saveOverallRecordingFeatures) {</span>
<span class="fc" id="L763">            rootDataSet.feature_values = windowFeatureValues[0];</span>
<span class="fc" id="L764">            rootDataSet.feature_names = IntStream.range(0, featureExtractorsNames.length)</span>
<span class="fc" id="L765">                    .filter(i -&gt; featuresToSaveMask[i])</span>
<span class="fc" id="L766">                    .mapToObj(i -&gt; featureExtractorsNames[i])</span>
<span class="fc" id="L767">                    .toArray(String[]::new);</span>
<span class="fc" id="L768">            dataSets.add(rootDataSet);</span>
<span class="fc" id="L769">            return;</span>
        }
<span class="fc" id="L771">        rootDataSet.sub_sets = new DataSet[windowFeatureValues.length];</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">        for (int win = 0; win &lt; windowFeatureValues.length; ++win) {</span>
<span class="fc" id="L773">            double startTime = MIDIMethods.getSecondsAtTick(startTicks[win], secondsPerTick);</span>
            //check for non-negative
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">            startTime = (startTime &gt; 0) ? startTime : 0;</span>
<span class="fc" id="L776">            double endTime = MIDIMethods.getSecondsAtTick(endTicks[win], secondsPerTick);</span>

<span class="fc" id="L778">            DataSet windowDataSet = new DataSet(null, null,</span>
<span class="fc" id="L779">                    startTime, endTime,</span>
<span class="fc" id="L780">                    windowFeatureValues[win], IntStream.range(0, featureExtractorsNames.length)</span>
<span class="fc" id="L781">                    .filter(i -&gt; featuresToSaveMask[i])</span>
<span class="fc" id="L782">                    .mapToObj(i -&gt; featureExtractorsNames[i])</span>
<span class="fc" id="L783">                    .toArray(String[]::new), rootDataSet);</span>
<span class="fc" id="L784">            rootDataSet.sub_sets[win] = windowDataSet;</span>
        }
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        if (overallFeatureValues != null) {</span>
<span class="nc" id="L787">            rootDataSet.feature_values = overallFeatureValues;</span>
<span class="nc" id="L788">            rootDataSet.feature_names = overallFeatureNames;</span>
        }
<span class="fc" id="L790">        dataSets.add(rootDataSet);</span>
<span class="fc" id="L791">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>