<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsymbolicProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jsymbolic-core</a> &gt; <a href="index.source.html" class="el_package">jsymbolic2.api</a> &gt; <span class="el_source">JsymbolicProcessor.java</span></div><h1>JsymbolicProcessor.java</h1><pre class="source lang-java linenums">package jsymbolic2.api;

import ace.datatypes.DataBoard;
import ace.datatypes.DataSet;
import jsymbolic2.configuration.ConfigFileHeaderEnum;
import jsymbolic2.configuration.ConfigurationFileData;
import jsymbolic2.configuration.txtimplementation.ConfigurationFileValidatorTxtImpl;
import jsymbolic2.featureutils.FeatureExtractorAccess;
import jsymbolic2.processing.FeatureExtractionJobProcessor;
import jsymbolic2.processing.MIDIReporter;
import jsymbolic2.processing.MusicFilter;
import jsymbolic2.processing.PrintStreams;
import jsymbolic2.processing.SaveInfo;
import jsymbolic2.processing.SymbolicMusicFileUtilities;
import jsymbolic2.processing.UserFeedbackGenerator;
import jsymbolic2.processing.WindowInfo;

import java.io.File;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * This class provides an API for programmatic access to jSymbolic's functionality. The constructor allows the
 * programmer to specify feature extraction settings, after which the methods of this class can be called to
 * extract features. Extracted feature values and associated metadata are saved to files, and may also be
 * returned in the form of a JsymbolicData object, depending on the particular method called. Separate
 * independent processing can also be performed via the static methods of this class.
 *
 * @author Tristano Tenaglia and Cory McKay
 */
public class JsymbolicProcessor {
    /* PRIVATE FIELDS ***************************************************************************************/


    /**
     * The path of the ACE XML Feature Values file to save extracted feature values to.
     */
    private final String feature_values_save_path;

    /**
     * The path of the ACE XML Feature Definitions file to save feature metadata about all extracted features
     * to.
     */
    private final String feature_definitions_save_path;

    /**
     * Whether or not to save extracted feature values in a Weka ARFF file. If this is set to true, the saved
     * file will have the same save path as that specified in feature_values_save_path, but with a different
     * file extension.
     */
    private final boolean save_arff_file;

    /**
     * Whether or not to save extracted feature values in a CSV file. If this is set to true, the saved file
     * will have the same save path as that specified in feature_values_save_path, but with a different file
     * extension.
     */
    private final boolean save_csv_file;

    /**
     * Which features to extract, as returned by a call to the FeatureExtractorAccess.findSpecifiedFeatures
     * method.
     */
    private final boolean[] features_to_extract;

    /**
     * Whether or not to extract features over each input file as a whole (i.e. without breaking each input
     * file into analysis windows. Note that if this is set to true, then save_features_for_each_window must
     * be set to false.
     */
    private final boolean save_features_for_overall_pieces;

    /**
     * Whether or not to break each input file into smaller analysis windows, and then extracting features
     * from these windows individually, rather than from pieces as a whole. Note that if this is set to true,
     * then save_features_for_overall_pieces must be set to false.
     */
    private final boolean save_features_for_each_window;

    /**
     * The duration of each analysis window, in seconds. Value is irrelevant if save_features_for_each_window
     * is set to false.
     */
    private final double analysis_window_size;

    /**
     * The fractional (0 to 1) overlap between consecutive analysis windows. Value is irrelevant if
     * save_features_for_each_window is set to false.
     */
    private final double analysis_window_overlap;

    /**
     * A stream to print processing status messages to as processing continues.
     */
    private final PrintStream status_print_stream;

    /**
     * A stream to print error messages to as processing continues.
     */
    private final PrintStream error_print_stream;


    /* CONSTRUCTORS *****************************************************************************************/


    /**
     * Instantiate a JsymbolicProcessor object with manually specified feature extraction settings. Note that
     * calling this constructor does NOT begin feature extraction from any input files; a separate method call
     * must be made after instantiation in order to do this.
     *
     * @param feature_values_save_path         The path of the ACE XML Feature Values file to save extracted
     *                                         feature values to.
     * @param feature_definitions_save_path    The path of the ACE XML Feature Definitions file to save
     *                                         feature metadata about all extracted features to.
     * @param save_arff_file                   Whether or not to save extracted feature values in a Weka
     *                                         ARFF file. If this is set to true, the saved file will have
     *                                         the same save path as that specified in
     *                                         feature_values_save_path, but with a different file extension.
     * @param save_csv_file                    Whether or not to save extracted feature values in a CSV file.
     *                                         If this is set to true, the saved file will have the same save
     *                                         path as that specified in feature_values_save_path, but with a
     *                                         different file extension.
     * @param names_of_features_to_extract     A list of feature names to extract. Note that the name of each
     *                                         feature must exactly match the name of the feature specified
     *                                         in its constructor and stored in the name field of its
     *                                         FeatureDefinition object.
     * @param save_features_for_overall_pieces Whether or not to extract features over each input file
     *                                         as a whole (i.e. without breaking each input file into
     *                                         analysis windows. Note that if this is set to true, then
     *                                         save_features_for_each_window must be set to false.
     * @param save_features_for_each_window    Whether or not to break each input file into smaller analysis
     *                                         windows, and then extracting features from these windows
     *                                         individually, rather than from pieces as a whole. Note that if
     *                                         this is set to true, then save_features_for_overall_pieces
     *                                         must be set to false.
     * @param analysis_window_size             The duration of each analysis window, in seconds. Value is
     *                                         irrelevant if save_features_for_each_window is set to false.
     * @param analysis_window_overlap          The fractional (0 to 1) overlap between consecutive analysis
     *                                         windows. Value is irrelevant if save_features_for_each_window
     *                                         is set to false.
     * @param status_print_stream              A stream to print processing status messages to as processing
     *                                         continues.
     * @param error_print_stream               A stream to print error messages to as processing continues.
     * @throws Exception Throws an exception if a particular feature name in the
     *                   names_of_features_to_extract list does not correspond to a
     *                   feature implemented in jSymbolic.
     */
    public JsymbolicProcessor(String feature_values_save_path,
                              String feature_definitions_save_path,
                              boolean save_arff_file,
                              boolean save_csv_file,
                              List&lt;String&gt; names_of_features_to_extract,
                              boolean save_features_for_overall_pieces,
                              boolean save_features_for_each_window,
                              double analysis_window_size,
                              double analysis_window_overlap,
                              PrintStream status_print_stream,
                              PrintStream error_print_stream)
<span class="fc" id="L161">            throws Exception {</span>
<span class="fc" id="L162">        this.feature_values_save_path = feature_values_save_path;</span>
<span class="fc" id="L163">        this.feature_definitions_save_path = feature_definitions_save_path;</span>
<span class="fc" id="L164">        this.save_arff_file = save_arff_file;</span>
<span class="fc" id="L165">        this.save_csv_file = save_csv_file;</span>
<span class="fc" id="L166">        features_to_extract = FeatureExtractorAccess.findSpecifiedFeatures(names_of_features_to_extract);</span>
<span class="fc" id="L167">        this.save_features_for_overall_pieces = save_features_for_overall_pieces;</span>
<span class="fc" id="L168">        this.save_features_for_each_window = save_features_for_each_window;</span>
<span class="fc" id="L169">        this.analysis_window_size = analysis_window_size;</span>
<span class="fc" id="L170">        this.analysis_window_overlap = analysis_window_overlap;</span>
<span class="fc" id="L171">        this.status_print_stream = status_print_stream;</span>
<span class="fc" id="L172">        this.error_print_stream = error_print_stream;</span>
<span class="fc" id="L173">    }</span>


    /**
     * Instantiate a JsymbolicProcessor object with manually specified feature extraction settings, and with
     * default features selected to be extracted (as specified by the
     * FeatureExtractorAccess.getNamesOfDefaultFeaturesToSave() method). Note that calling this constructor
     * does NOT begin feature extraction from any input files; a separate method call must be made after
     * instantiation in order to do this.
     *
     * @param feature_values_save_path         The path of the ACE XML Feature Values file to save extracted
     *                                         feature values to.
     * @param feature_definitions_save_path    The path of the ACE XML Feature Definitions file to save
     *                                         feature metadata about all extracted features to.
     * @param save_arff_file                   Whether or not to save extracted feature values in a Weka
     *                                         ARFF file. If this is set to true, the saved file will have
     *                                         the same save path as that specified in
     *                                         feature_values_save_path, but with a different file extension.
     * @param save_csv_file                    Whether or not to save extracted feature values in a CSV file.
     *                                         If this is set to true, the saved file will have the same save
     *                                         path as that specified in feature_values_save_path, but with a
     *                                         different file extension.
     * @param save_features_for_overall_pieces Whether or not to extract features over each input file
     *                                         as a whole (i.e. without breaking each input file into
     *                                         analysis windows. Note that if this is set to true, then
     *                                         save_features_for_each_window must be set to false.
     * @param save_features_for_each_window    Whether or not to break each input file into smaller analysis
     *                                         windows, and then extracting features from these windows
     *                                         individually, rather than from pieces as a whole. Note that if
     *                                         this is set to true, then save_features_for_overall_pieces
     *                                         must be set to false.
     * @param analysis_window_size             The duration of each analysis window, in seconds. Value is
     *                                         irrelevant if save_features_for_each_window is set to false.
     * @param analysis_window_overlap          The fractional (0 to 1) overlap between consecutive analysis
     *                                         windows. Value is irrelevant if save_features_for_each_window
     *                                         is set to false.
     * @param status_print_stream              A stream to print processing status messages to as processing
     *                                         continues.
     * @param error_print_stream               A stream to print error messages to as processing continues.
     * @throws Exception Throws an exception if a particular feature name in the
     *                   names_of_features_to_extract list does not correspond to a
     *                   feature implemented in jSymbolic.
     */
    public JsymbolicProcessor(String feature_values_save_path,
                              String feature_definitions_save_path,
                              boolean save_arff_file,
                              boolean save_csv_file,
                              boolean save_features_for_overall_pieces,
                              boolean save_features_for_each_window,
                              double analysis_window_size,
                              double analysis_window_overlap,
                              PrintStream status_print_stream,
                              PrintStream error_print_stream)
            throws Exception {
<span class="nc" id="L227">        this(feature_values_save_path,</span>
                feature_definitions_save_path,
                save_arff_file,
                save_csv_file,
<span class="nc" id="L231">                FeatureExtractorAccess.getNamesOfDefaultFeaturesToSave(),</span>
                save_features_for_overall_pieces,
                save_features_for_each_window,
                analysis_window_size,
                analysis_window_overlap,
                status_print_stream,
                error_print_stream);
<span class="nc" id="L238">    }</span>


    /**
     * Instantiate a JsymbolicProcessor object with feature extraction settings specified in a jSymbolic
     * configuration settings file. An invalid configuration file will result in an error being output to the
     * provided error_print_stream and an exception being thrown. Note that calling this constructor does NOT
     * begin feature extraction from any input files that may (or may not) be specified in the configuration
     * settings file; a separate method call must be made after instantiation in order to do this. Also note
     * that this constructor does not cause the paths to any input files that may be stored in the
     * configuration settings file to be stored in the newly instantiated object.
     *
     * @param configuration_file_path The path to a jSymbolic configuration settings file. This
     *                                configuration file must be valid, and must contain extraction
     *                                settings, output paths and features to extract. It does not, however,
     *                                need to specify input files (these are ignored if present).
     * @param status_print_stream     A stream to print processing status messages to as processing
     *                                continues.
     * @param error_print_stream      A stream to print error messages to as processing continues.
     * @throws Exception Throws an exception if the configuration_file_path does not refer to a
     *                   valid configuration file .
     */
    public JsymbolicProcessor(String configuration_file_path,
                              PrintStream status_print_stream,
                              PrintStream error_print_stream)
<span class="fc" id="L263">            throws Exception {</span>
        ConfigurationFileData config_data;
        try {
<span class="fc" id="L266">            UserFeedbackGenerator.printParsingConfigFileMessage(status_print_stream, configuration_file_path);</span>
<span class="fc" id="L267">            List&lt;ConfigFileHeaderEnum&gt; config_file_headers_to_check = Arrays.asList(ConfigFileHeaderEnum.FEATURE_HEADER,</span>
                    ConfigFileHeaderEnum.OPTION_HEADER,
                    ConfigFileHeaderEnum.OUTPUT_FILE_HEADER);
<span class="fc" id="L270">            config_data = new ConfigurationFileValidatorTxtImpl().parseConfigFile(configuration_file_path,</span>
                    config_file_headers_to_check,
                    error_print_stream);
<span class="nc" id="L273">        } catch (Exception e) {</span>
<span class="nc" id="L274">            UserFeedbackGenerator.printExceptionErrorMessage(System.err, e);</span>
<span class="nc" id="L275">            throw e;</span>
<span class="fc" id="L276">        }</span>

<span class="fc" id="L278">        feature_values_save_path = config_data.getFeatureValueSavePath();</span>
<span class="fc" id="L279">        feature_definitions_save_path = config_data.getFeatureDefinitionSavePath();</span>
<span class="fc" id="L280">        save_arff_file = config_data.convertToArff();</span>
<span class="fc" id="L281">        save_csv_file = config_data.convertToCsv();</span>
<span class="fc" id="L282">        features_to_extract = config_data.getFeaturesToSaveBoolean();</span>
<span class="fc" id="L283">        save_features_for_overall_pieces = config_data.saveOverall();</span>
<span class="fc" id="L284">        save_features_for_each_window = config_data.saveWindow();</span>
<span class="fc" id="L285">        analysis_window_size = config_data.getWindowSize();</span>
<span class="fc" id="L286">        analysis_window_overlap = config_data.getWindowOverlap();</span>
<span class="fc" id="L287">        this.status_print_stream = status_print_stream;</span>
<span class="fc" id="L288">        this.error_print_stream = error_print_stream;</span>
<span class="fc" id="L289">    }</span>


    /* PUBLIC METHODS ***************************************************************************************/


    /**
     * Extracts and saves features from the specified path_of_file_or_folder_to_parse. Carries out these
     * operations using the settings with which this JsymbolicProcessor object was instantiated. If
     * path_of_file_or_folder_to_parse refers to a folder rather than a file, then all qualifying files (i.e.
     * MIDI or MEI) in it have their features extracted. Provides status updates as processing continues. Any
     * errors occurring during processing are reported on error_print_stream, and are also collected for
     * summarization at the end of processing. Processing continues even if errors are encountered, with three
     * exceptions: if the JVM runs out of memory, if an MEI-specific feature is set to be extracted from a
     * non-MEI file, or if MIDIFeatureProcessor cannot be initialized. In the latter three cases, execution is
     * terminated immediately.
     *
     * @param path_of_file_or_folder_to_parse The path of a file to extract features from, or of a directory
     *                                        holding files to extract features from.
     * @return A list of errors that may have occurred during processing.
     * Will be empty if no errors occurred. Note that this often
     * simply duplicates what is written to error_print_stream.
     */
    public List&lt;String&gt; extractAndSaveFeaturesFromFileOrDirectory(String path_of_file_or_folder_to_parse) {
<span class="fc" id="L313">        SaveInfo saveInfo = new SaveInfo(feature_values_save_path, feature_definitions_save_path, save_features_for_overall_pieces, save_arff_file, save_csv_file);</span>
<span class="fc" id="L314">        WindowInfo windowInfo = new WindowInfo(save_features_for_each_window, analysis_window_size, analysis_window_overlap);</span>
<span class="fc" id="L315">        PrintStreams printStreams = new PrintStreams(status_print_stream, error_print_stream);</span>
<span class="fc" id="L316">        return FeatureExtractionJobProcessor.extractAndSaveSpecificFeatures(List.of(new File(path_of_file_or_folder_to_parse)),</span>
                saveInfo,
                features_to_extract,
                windowInfo,
                printStreams,
                false);
    }


    /**
     * Parse saved extracted feature values and associated metadata (e.g. feature definitions) and return them
     * in the form of an ace.datatypes.DataBoard object. Note that this method should only be called after
     * features have been successfully extracted and saved as an ACE XML feature values file at the
     * feature_values_save_path specified when the constructor of this object was called. Such a feature
     * extraction would typically have been performed using one of this object's extractAndSaveFeatures
     * methods. Note that problems encountered are written to error_print_stream and also result in a thrown
     * exception.
     *
     * @throws Exception An informative exception is thrown if a valid ACE XML file holding extracted
     *                   feature values cannot be found at the path specified by this object's
     *                   feature_values_save_path field.
     * @return An ace.datatypes.DataBoard object holding the extracted feature values as well
     * as associated feature definitions (which are parsed from the ACE XML feature
     * definitions file saved at the path specified by this object's
     * feature_definitions_save_path field). See the ACE project's documentation for more
     * details.
     */
    public DataBoard getCompleteExtractedFeatureInformation()
            throws Exception {
        // Verify that a file exists at feature_values_save_path. Throw an exception if it does not.
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (null == feature_values_save_path) {</span>
<span class="nc" id="L347">            String error_message = &quot;No save path for extracted feature valuse has been specified, so cannot access saved extracted feature values.&quot;;</span>
<span class="nc" id="L348">            UserFeedbackGenerator.printErrorMessage(error_print_stream, error_message);</span>
<span class="nc" id="L349">            throw new Exception(error_message);</span>
        }
        try {
<span class="fc" id="L352">            mckay.utilities.staticlibraries.FileMethods.validateFile(new File(feature_values_save_path), true, false);</span>
<span class="nc" id="L353">        } catch (Exception e) {</span>
<span class="nc" id="L354">            String error_message = &quot;Cannot access the ACE XML file containing extracted features: &quot; + feature_values_save_path + &quot;. Perhaps features have not been extracted yet?&quot;;</span>
<span class="nc" id="L355">            UserFeedbackGenerator.printErrorMessage(error_print_stream, error_message);</span>
<span class="nc" id="L356">            throw new Exception(error_message);</span>
<span class="fc" id="L357">        }</span>

        // Parse the ACE XML feature values and feature definitions file.
<span class="fc" id="L360">        String[] feature_values_paths = {feature_values_save_path};</span>
<span class="fc" id="L361">        DataBoard feature_values_and_definitions = new DataBoard(null,</span>
                feature_definitions_save_path,
                feature_values_paths,
                null);

        // Return the results
<span class="fc" id="L367">        return feature_values_and_definitions;</span>
    }


    /**
     * Parse saved extracted feature values and return them in the form of an array of ace.datatypes.DataSet
     * objects. Note that this method should only be called after features have been successfully extracted
     * and saved as an ACE XML feature values file at the feature_values_save_path specified when the
     * constructor of this object was called. Such a feature extraction would typically have been performed
     * using one of this object's extractAndSaveFeatures methods. Note that problems encountered are written
     * to error_print_stream and also result in a thrown exception.
     *
     * @throws Exception An informative exception is thrown if a valid ACE XML file holding extracted
     *                   feature values cannot be found at the path specified by this object's
     *                   feature_values_save_path field.
     * @return An array of ace.datatypes.DataSet objects holding the extracted feature values.
     * Each DataSet object corresponds to a different piece of music from which features
     * were extracted. If windowed extraction was performed, then each DataSet object in
     * the returned array will also hold its own array of DataSet objects, one for each
     * extracted window. Feature values are contained in the feature_values field of
     * each DataSet object (both single and multi-dimensional features), feature names
     * are contained in the feature_names field, and an identifier for each instance
     * is stored in the identifier field. See the ACE project's documentation for more
     * details.
     */
    public DataSet[] getExtractedFeatureValues()
            throws Exception {
<span class="fc" id="L394">        DataBoard feature_values_and_definitions = getCompleteExtractedFeatureInformation();</span>
<span class="fc" id="L395">        return feature_values_and_definitions.getFeatureVectors();</span>
    }


    /* PUBLIC STATIC METHODS ********************************************************************************/


    /**
     * Parse the MIDI and/or MEI files referred to in file_or_directory_path (either a single file or a
     * directory holding MIDI and/or MEI files) and return formatted ordered reports on whether or not certain
     * musical characteristics are consistent both across the files as a group, and internally within each
     * file. In the case of directories, processing is recursive, and only files with qualifying MIDI or MEI
     * file extensions are included. Problems that are encountered can result in an exception being thrown
     * and/or a message being printed to standard error.
     *
     * @param file_or_directory_path Either a single file or a directory holding MIDI and/or MEI files.
     *                               Generate the report based on these files.
     * @throws Exception An informative exception is thrown if there is a problem with the
     *                   specified file_or_directory_path.
     * @return The formatted report.
     */
    public static String getConsistencyReport(String file_or_directory_path)
            throws Exception {
        // Prepare the set of files (after recursive directory parsing and extension filtering, if
        // appropriate), to report on
<span class="nc" id="L420">        File[] midi_or_mei_file_list = SymbolicMusicFileUtilities.getRecursiveListOfFiles(file_or_directory_path,</span>
                new MusicFilter(),
                System.err,
                new ArrayList&lt;&gt;());

        // Prepare and return the report
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (null != midi_or_mei_file_list)</span>
<span class="nc" id="L427">            return MIDIReporter.prepareConsistencyReports(midi_or_mei_file_list, true, true, true);</span>
        else
<span class="nc" id="L429">            throw new Exception(&quot;Null file or directory path provided.&quot;);</span>
    }


    /**
     * Parse the MIDI and/or MEI files referred to in file_or_directory_path (either a single file or a
     * directory holding MIDI and/or MEI files) and return formatted ordered reports on the MIDI messages
     * contained in these files. This report indicates, separately for each file, a structured transcription
     * of all the relevant MIDI messages that the given file contains. If a given file is an MEI rather than a
     * MIDI file, then it is converted to MIDI before reporting. In the case of directories, processing is
     * recursive, and only files with qualifying MIDI or MEI file extensions are included. Problems that are
     * encountered can result in an exception being thrown and/or a message being printed to standard error.
     *
     * @param file_or_directory_path Either a single file or a directory holding MIDI and/or MEI files.
     *                               Generate the report based on these files.
     * @throws Exception An informative exception is thrown if there is a problem with the
     *                   specified file_or_directory_path.
     * @return The formatted report.
     */
    public static String getMidiContentsReport(String file_or_directory_path)
            throws Exception {
        // Prepare the set of files (after recursive directory parsing and extension filtering, if
        // appropriate), to report on
<span class="nc" id="L452">        File[] midi_or_mei_file_list = SymbolicMusicFileUtilities.getRecursiveListOfFiles(file_or_directory_path,</span>
                new MusicFilter(),
                System.err,
                new ArrayList&lt;&gt;());

        // Prepare and output the reports
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (null != midi_or_mei_file_list) {</span>
            // The report to display
<span class="nc" id="L460">            StringBuilder report = new StringBuilder();</span>

            // Report on each file
<span class="nc bnc" id="L463" title="All 2 branches missed.">            for (int i = 0; i &lt; midi_or_mei_file_list.length; i++) {</span>
                // Parse and check the MIDI file
<span class="nc" id="L465">                MIDIReporter midi_debugger = new MIDIReporter(midi_or_mei_file_list[i]);</span>

                // Generate the report
<span class="nc" id="L468">                report.append(&quot;\n============ MIDI MESSAGES REPORT FOR FILE &quot; + (i + 1) + &quot; / &quot; + midi_or_mei_file_list.length + &quot; ============\n&quot;);</span>
<span class="nc" id="L469">                report.append(midi_debugger.prepareHeaderReport());</span>
<span class="nc" id="L470">                report.append(midi_debugger.prepareMetaMessageReport(true, true, true, true, true, true));</span>
<span class="nc" id="L471">                report.append(midi_debugger.prepareProgramChangeAndUnpitchedInstrumentsReport());</span>
<span class="nc" id="L472">                report.append(midi_debugger.prepareControllerMessageReport());</span>
<span class="nc" id="L473">                report.append(midi_debugger.prepareNoteReport(false, true));</span>
            }

            // Return the report
<span class="nc" id="L477">            return report.toString();</span>
<span class="nc" id="L478">        } else throw new Exception(&quot;Null file or directory path provided.&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>