<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChordTypeEnum.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jsymbolic-core</a> &gt; <a href="index.source.html" class="el_package">jsymbolic2.featureutils</a> &gt; <span class="el_source">ChordTypeEnum.java</span></div><h1>ChordTypeEnum.java</h1><pre class="source lang-java linenums">package jsymbolic2.featureutils;

import java.util.ArrayList;
import java.util.List;

/**
 * An enumerator that can be used to identify the type of chord a set of pitch classes represents using the
 * getChordType method. Each chord type is associated with a specific numerical code. The possible chord types
 * and their associated codes are as follows:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;PARTIAL_CHORD (0)&lt;/b&gt;: Any set of pitch classes consisting of exactly two different pitch classes.
 * &lt;li&gt;&lt;b&gt;MINOR_TRIAD (1)&lt;/b&gt;: A set of three pitch classes comprising a minor triad, in any inversion.
 * &lt;li&gt;&lt;b&gt;MAJOR_TRIAD (2)&lt;/b&gt;: A set of three pitch classes comprising a major triad, in any inversion.
 * &lt;li&gt;&lt;b&gt;DIMINISHED_TRIAD (3)&lt;/b&gt;: A set of three pitch classes comprising a diminished triad, in any inversion.
 * &lt;li&gt;&lt;b&gt;AUGMENTED_TRIAD (4)&lt;/b&gt;: A set of three pitch classes comprising an augmented triad, in any inversion.
 * &lt;li&gt;&lt;b&gt;OTHER_TRIAD (5)&lt;/b&gt;: Any set of notes consisting of exactly three different pitch classes. Note that, although this does technically include any triad, in practice it excludes minor, major, diminished and augmented triads when the getChordType method is called (because of order of processing).
 * &lt;li&gt;&lt;b&gt;MINOR_SEVENTH (6)&lt;/b&gt;: A set of four pitch classes comprising a minor seventh chord, in any inversion.
 * &lt;li&gt;&lt;b&gt;DOMINANT_SEVENTH (7)&lt;/b&gt;: A set of four pitch classes comprising a dominant seventh chord, in any inversion.
 * &lt;li&gt;&lt;b&gt;MAJOR_SEVENTH (8)&lt;/b&gt;: A set of four pitch classes comprising a major seventh chord, in any inversion.
 * &lt;li&gt;&lt;b&gt;OTHER_FOUR_NOTE_CHORD (9)&lt;/b&gt;: Any set of notes consisting of exactly four different pitch classes. Note that, although this does technically include any four note chord, in practice it excludes minor seventh, dominant seventh and major seventh chords when the getChordType method is called (because of order of processing).
 * &lt;li&gt;&lt;b&gt;COMPLEX_CHORD (10)&lt;/b&gt;: Any set of notes consisting of more than four different pitch classes.
 * &lt;/ul&gt;
 *
 * @author Tristano Tenaglia and Cory McKay
 */
<span class="fc" id="L27">public enum ChordTypeEnum {</span>
    /* CONSTANTS ********************************************************************************************/


    // Call the constructor for each constant, specifying each associated validator and chord_type_code
<span class="fc" id="L32">    PARTIAL_CHORD(ChordTypeValidationEnum.PARTIAL_CHORD_VALIDATION, 0),</span>
<span class="fc" id="L33">    MINOR_TRIAD(ChordTypeValidationEnum.MINOR_TRIAD_VALIDATION, 1),</span>
<span class="fc" id="L34">    MAJOR_TRIAD(ChordTypeValidationEnum.MAJOR_TRIAD_VALIDATION, 2),</span>
<span class="fc" id="L35">    DIMINISHED_TRIAD(ChordTypeValidationEnum.DIMINISHED_TRIAD_VALIDATION, 3),</span>
<span class="fc" id="L36">    AUGMENTED_TRIAD(ChordTypeValidationEnum.AUGMENTED_TRIAD_VALIDATION, 4),</span>
<span class="fc" id="L37">    OTHER_TRIAD(ChordTypeValidationEnum.OTHER_TRIAD_VALIDATION, 5),</span>
<span class="fc" id="L38">    MINOR_SEVENTH(ChordTypeValidationEnum.MINOR_SEVENTH_VALIDATION, 6),</span>
<span class="fc" id="L39">    DOMINANT_SEVENTH(ChordTypeValidationEnum.DOMINANT_SEVENTH_VALIDATION, 7),</span>
<span class="fc" id="L40">    MAJOR_SEVENTH(ChordTypeValidationEnum.MAJOR_SEVENTH_VALIDATION, 8),</span>
<span class="fc" id="L41">    OTHER_FOUR_NOTE_CHORD(ChordTypeValidationEnum.OTHER_FOUR_NOTE_CHORD_VALIDATION, 9),</span>
<span class="fc" id="L42">    COMPLEX_CHORD(ChordTypeValidationEnum.COMPLEX_CHORD_VALIDATION, 10);</span>


    /* FIELDS ***********************************************************************************************/


    /**
     * A ChordTypeValidationEnum identifying the type of chord and providing a method for checking to see if
     * any given set of pitch classes corresponds to this chord type.
     */
    private final ChordTypeValidationEnum validator;

    /**
     * The code indicating the type of chord this is.
     */
    private final int chord_type_code;


    /* CONSTRUCTOR ******************************************************************************************/


    /**
     * Instantiate a ChordTypeEnum corresponding to a certain type of code, as specified by validator and
     * chord_type_code.
     *
     * @param validator       A ChordTypeValidationEnum identifying the type of chord and providing a method
     *                        for checking to see if any given set of pitch classes corresponds to this
     *                        chord type.
     * @param chord_type_code A code matching the specified validator.
     */
<span class="fc" id="L72">    ChordTypeEnum(ChordTypeValidationEnum validator, int chord_type_code) {</span>
<span class="fc" id="L73">        this.validator = validator;</span>
<span class="fc" id="L74">        this.chord_type_code = chord_type_code;</span>
<span class="fc" id="L75">    }</span>


    /* PUBLIC METHODS ***************************************************************************************/


    /**
     * @return Get the code indicating the type of chord this is.
     */
    public int getChordTypeCode() {
<span class="fc" id="L85">        return chord_type_code;</span>
    }



    /* PUBLIC STATIC METHODS ********************************************************************************/


    /**
     * Identify the type of chord represented by the given pitch classes.
     *
     * @param pitch_class_strengths An array of size 12 whose index corresponds to the 12 pitch classes, with
     *                              index 0 corresponding to the note C. The magnitude of each bin corresponds
     *                              to the accumulated MIDI velocity of all notes with the given pitch class
     *                              that are sounding (not including Channel 10 unpitched notes). A value of
     *                              zero in a given bin therefore means that the pitch class with the
     *                              corresponding index is not present. For example, the array
     *                              [10, 0, 0, 0, 20, 0, 0, 64, 0, 0, 0, 0] corresponds to a C major chord,
     *                              where the G is most emphasized, and C is least emphasized.
     * @throws Exception An informative exception is thrown if pitch_classes_present is null or is
     *                   not size 12.
     * @return An identifier indicating the type of chord that pitch_class_strengths
     * represents. Null is returned if  pitch_class_strengths does not correspond
     * to a recognized chord type.
     */
    public static ChordTypeEnum getChordType(int[] pitch_class_strengths)
            throws Exception {
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">        if (null == pitch_class_strengths || 12 != pitch_class_strengths.length)</span>
<span class="nc" id="L113">            throw new Exception(&quot;The specified set of pitch classes is null or does not correspond to a known chord type.\n&quot;);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (ChordTypeEnum chord_type : ChordTypeEnum.values())</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (chord_type.validator.validate(pitch_class_strengths))</span>
<span class="fc" id="L116">                return chord_type;</span>
<span class="fc" id="L117">        return null; //if no chord type is found</span>
    }


    /* INTERNAL ENUM ****************************************************************************************/


    /**
     * An enumeration of chord type validators, one for each chord type, each of which has its own validate
     * method to check to see if any given set of pitch classes belongs to the given type of chord.
     */
<span class="fc" id="L128">    private enum ChordTypeValidationEnum {</span>
        /* CONSTANTS ****************************************************************************************//* CONSTANTS ****************************************************************************************/


        // Implement an appropriate validate method for each type of chord
<span class="fc" id="L133">        PARTIAL_CHORD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L136">                return ChordTypeValidationEnum.checkNumberOfPitchClasses(pitch_class_strengths, 2);</span>
            }
        },
<span class="fc" id="L139">        MINOR_TRIAD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L142">                int minor_triad_length = 3;</span>
<span class="fc" id="L143">                int[] root_position = {3, 4};</span>
<span class="fc" id="L144">                int[] first_inversion = {4, 5};</span>
<span class="fc" id="L145">                int[] second_inversion = {5, 3};</span>
<span class="fc" id="L146">                int[][] minor_triad_intervals = {root_position, first_inversion, second_inversion};</span>

<span class="fc" id="L148">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, minor_triad_length, minor_triad_intervals);</span>
            }
        },
<span class="fc" id="L151">        MAJOR_TRIAD_VALIDATION {</span>
            @Override
            public boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L154">                int major_triad_length = 3;</span>
<span class="fc" id="L155">                int[] root_position = {4, 3};</span>
<span class="fc" id="L156">                int[] first_inversion = {3, 5};</span>
<span class="fc" id="L157">                int[] second_inversion = {5, 4};</span>
<span class="fc" id="L158">                int[][] major_triad_intervals = {root_position, first_inversion, second_inversion};</span>

<span class="fc" id="L160">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, major_triad_length, major_triad_intervals);</span>
            }
        },
<span class="fc" id="L163">        DIMINISHED_TRIAD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L166">                int diminished_triad_length = 3;</span>
<span class="fc" id="L167">                int[] root_position = {3, 3};</span>
<span class="fc" id="L168">                int[] first_inversion = {3, 6};</span>
<span class="fc" id="L169">                int[] second_inversion = {6, 3};</span>
<span class="fc" id="L170">                int[][] diminished_triad_intervals = {root_position, first_inversion, second_inversion};</span>

<span class="fc" id="L172">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, diminished_triad_length, diminished_triad_intervals);</span>
            }
        },
<span class="fc" id="L175">        AUGMENTED_TRIAD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L178">                int augmented_triad_length = 3;</span>
<span class="fc" id="L179">                int[] root_position = {4, 4};</span>
<span class="fc" id="L180">                int[] first_inversion = {4, 4};</span>
<span class="fc" id="L181">                int[] second_inversion = {4, 4};</span>
<span class="fc" id="L182">                int[][] augmented_triad_intervals = {root_position, first_inversion, second_inversion};</span>

<span class="fc" id="L184">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, augmented_triad_length, augmented_triad_intervals);</span>
            }
        },
<span class="fc" id="L187">        OTHER_TRIAD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L190">                return ChordTypeValidationEnum.checkNumberOfPitchClasses(pitch_class_strengths, 3);</span>
            }
        },
<span class="fc" id="L193">        MINOR_SEVENTH_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L196">                int minor_seventh_length = 4;</span>
<span class="fc" id="L197">                int[] root_position = {3, 4, 3};</span>
<span class="fc" id="L198">                int[] first_inversion = {4, 3, 2};</span>
<span class="fc" id="L199">                int[] second_inversion = {3, 2, 3};</span>
<span class="fc" id="L200">                int[] third_inversion = {2, 3, 4};</span>
<span class="fc" id="L201">                int[][] minor_seventh_intervals = {root_position, first_inversion, second_inversion, third_inversion};</span>

<span class="fc" id="L203">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, minor_seventh_length, minor_seventh_intervals);</span>
            }
        },
<span class="fc" id="L206">        DOMINANT_SEVENTH_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L209">                int dominant_seventh_length = 4;</span>
<span class="fc" id="L210">                int[] root_position = {4, 3, 3};</span>
<span class="fc" id="L211">                int[] first_inversion = {3, 3, 2};</span>
<span class="fc" id="L212">                int[] second_inversion = {3, 2, 4};</span>
<span class="fc" id="L213">                int[] third_inversion = {2, 4, 3};</span>
<span class="fc" id="L214">                int[][] dominant_seventh_intervals = {root_position, first_inversion, second_inversion, third_inversion};</span>

<span class="fc" id="L216">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, dominant_seventh_length, dominant_seventh_intervals);</span>
            }
        },
<span class="fc" id="L219">        MAJOR_SEVENTH_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L222">                int major_seventh_length = 4;</span>
<span class="fc" id="L223">                int[] root_position = {4, 3, 4};</span>
<span class="fc" id="L224">                int[] first_inversion = {3, 4, 1};</span>
<span class="fc" id="L225">                int[] second_inversion = {4, 1, 4};</span>
<span class="fc" id="L226">                int[] third_inversion = {1, 4, 3};</span>
<span class="fc" id="L227">                int[][] major_seventh_intervals = {root_position, first_inversion, second_inversion, third_inversion};</span>

<span class="fc" id="L229">                return ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervalsWithInversions(pitch_class_strengths, major_seventh_length, major_seventh_intervals);</span>
            }
        },
<span class="fc" id="L232">        OTHER_FOUR_NOTE_CHORD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc" id="L235">                return ChordTypeValidationEnum.checkNumberOfPitchClasses(pitch_class_strengths, 4);</span>
            }
        },
<span class="fc" id="L238">        COMPLEX_CHORD_VALIDATION {</span>
            @Override
            boolean validate(int[] pitch_class_strengths) {
<span class="fc bfc" id="L241" title="All 2 branches covered.">                for (int num_pitch_classes = 5; num_pitch_classes &lt; pitch_class_strengths.length; num_pitch_classes++)</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                    if (ChordTypeValidationEnum.checkNumberOfPitchClasses(pitch_class_strengths, num_pitch_classes))</span>
<span class="fc" id="L243">                        return true;</span>
<span class="fc" id="L244">                return false;</span>
            }
        };


        /* ABSTRACT METHOD **********************************************************************************/


        /**
         * Return true if the given pitch_class_strengths match the type of chord corresponding to the
         * implementing ChordTypeValidationEnum constant.
         *
         * @param pitch_class_strengths An array of size 12 whose index corresponds to the 12 pitch classes,
         *                              with index 0 corresponding to the note C. The magnitude of each bin
         *                              corresponds to the accumulated MIDI velocity of all notes with the
         *                              given pitch class that are sounding (not including Channel 10
         *                              unpitched notes). A value of zero in a given bin therefore means that
         *                              the pitch class with the corresponding index is not present. For
         *                              example, the array [10, 0, 0, 0, 20, 0, 0, 64, 0, 0, 0, 0] corresponds
         *                              to a C major chord, where the G is most emphasized, and C is least
         *                              emphasized.
         * @return True if pitch_class_strengths represents the implementing constant's
         * chord type, false otherwise.
         */
        abstract boolean validate(int[] pitch_class_strengths);


        /* PRIVATE STATIC METHODS ***************************************************************************/


        /**
         * Check to see if the pitch classes present in pitch_class_strengths are separated by one of the
         * sets of intervals specified in possible_interval_sets. Note that the actual MIDI velocity strengths
         * specified in pitch_class_strengths are only considered here in terms of whether they are present
         * (non-zero) or absent (zero).
         *
         * @param pitch_class_strengths  An array of size 12 whose index corresponds to the 12 pitch
         *                               classes, with index 0 corresponding to the note C. The magnitude
         *                               of each bin corresponds to the accumulated MIDI velocity of all
         *                               notes with the given pitch class that are sounding (not including
         *                               Channel 10 unpitched notes). A value of zero in a given bin
         *                               therefore means that the pitch class with the corresponding index
         *                               is not present. For example, the array
         *                               [10, 0, 0, 0, 20, 0, 0, 64, 0, 0, 0, 0] corresponds	to a C major
         *                               chord, where the G is most emphasized, and C is least emphasized.
         * @param number_expected_pcs    Number of non-zero pitch classes expected in
         *                               pitch_class_strengths.
         * @param possible_interval_sets An array of arrays of ordered pitch intervals (in semitones). The
         *                               outer index identifies a possible inversion of a chord type
         *                               under consideration (e.g. root position, first inversion, etc.).
         *                               Each entry of an inner array indicates a pitch interval (in
         *                               semitones) expected for the given inversion of the expected chord
         *                               type. For example, the possible_interval_sets for a minor triad
         *                               would be [[3,4],[4,5],[5,3]]. Each of these interval sets are
         *                               compared to the actual intervals between pitch classes present in
         *                               pitch_class_strengths to see if these pitch classes to in fact
         *                               correspond to one of the inversions of the chord type under
         *                               consideration.
         * @return True if the pitch classes present in pitch_class_strengths
         * correspond one of the sets of pitch intervals specified in
         * possible_interval_sets. Return false otherwise.
         */
        private static boolean verifyPitchClassesMatchExpectedIntervalsWithInversions(int[] pitch_class_strengths,
                                                                                      int number_expected_pcs,
                                                                                      int[][] possible_interval_sets) {
            // Verify that the appropriate number of pitch classes are present
<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (!ChordTypeValidationEnum.checkNumberOfPitchClasses(pitch_class_strengths, number_expected_pcs))</span>
<span class="fc" id="L311">                return false;</span>

            // Verify that that number of pitch classes present matches the number of possible inversions
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            if (number_expected_pcs != possible_interval_sets.length)</span>
<span class="nc" id="L315">                return false;</span>

            // Verify that the number of pich clases is appropriately matched to the number of intervals in
            // the first specified inversion, at least
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (number_expected_pcs != possible_interval_sets[0].length + 1)</span>
<span class="nc" id="L320">                return false;</span>

            // Prepare a list of all pitch class numbers that have a non-zero accumulated MIDI velocity
            // (i.e. a list of of pitch classes present)
<span class="fc" id="L324">            List&lt;Integer&gt; pitch_classes_present = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">            for (int i = 0; i &lt; pitch_class_strengths.length; i++)</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">                if (0 &lt; pitch_class_strengths[i])</span>
<span class="fc" id="L327">                    pitch_classes_present.add(i);</span>

            // Check each possible inversion specified in possible_interval_sets to see if one of them
            // contains intervals correspoinding to the specified pitch classes present
<span class="fc bfc" id="L331" title="All 2 branches covered.">            for (int inv = 0; inv &lt; possible_interval_sets.length; inv++)</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (ChordTypeValidationEnum.verifyPitchClassesMatchExpectedIntervals(pitch_classes_present, possible_interval_sets[inv]))</span>
<span class="fc" id="L333">                    return true;</span>

            // Return false if the pitch classes present do not match any of the specified sets of intervals
<span class="fc" id="L336">            return false;</span>
        }


        /**
         * Compare the given pitch_classes_present with the given expected_intervals in order to see if the
         * pitch classes present really are separated by the specified intervals (taking order into account).
         *
         * @param pitch_classes_present A list of pitch class identifiers noting all pitch classes present.
         *                              0 corresponds to C, 1 to C#/Db, 2 to D, etc. These must be pre-sorted
         *                              from smallest to largest.
         * @param expected_intervals    An array of pitch intervals (in semitones). These are compared with
         *                              the pitch classes specified in pitch_classes_present (taking order
         *                              into account), in order to see if the pitch classes there are in fact
         *                              separated by the intervals specified here.
         * @return True if the expected_intervals correspond to pitch_classes_present,
         * false otherwise.
         */
        private static boolean verifyPitchClassesMatchExpectedIntervals(List&lt;Integer&gt; pitch_classes_present,
                                                                        int[] expected_intervals) {
            // Verify that that the number of pitch classes and intervals are appropriate for one another
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">            if (pitch_classes_present.size() != expected_intervals.length + 1)</span>
<span class="nc" id="L358">                return false;</span>

            // Check if the pitches are in fact separated by the expected intervals
<span class="fc" id="L361">            boolean[] matching_intervals = new boolean[expected_intervals.length];</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            for (int pc = 0; pc &lt; pitch_classes_present.size() - 1; pc++) {</span>
<span class="fc" id="L363">                int actual_interval = Math.abs(pitch_classes_present.get(pc) - pitch_classes_present.get(pc + 1));</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                matching_intervals[pc] = actual_interval == expected_intervals[pc];</span>
            }

            // Only return true if all intervals match
<span class="fc" id="L368">            return ChordTypeValidationEnum.checkAllEntriesTrue(matching_intervals);</span>
        }


        /**
         * Check if the number of (non-zero) pitch classes in pitch_classes_present match that specified in
         * number_expected_pitch_classes.
         *
         * @param pitch_class_strengths An array of size 12 whose index corresponds to the 12 pitch classes,
         *                              with index 0 corresponding to the note C. The magnitude of each bin
         *                              corresponds to the accumulated MIDI velocity of all notes with the
         *                              given pitch class that are sounding (not including Channel 10
         *                              unpitched notes). A value of zero in a given bin therefore means that
         *                              the pitch class with the corresponding index is not present. For
         *                              example, the array [10, 0, 0, 0, 20, 0, 0, 64, 0, 0, 0, 0] corresponds
         *                              to a C major chord, where the G is most emphasized, and C is least
         *                              emphasized.
         * @param number_expected_pcs   Number of non-zero pitch classes expected in pitch_class_strengths.
         * @return True if number_expected_pcs matches the number of non-zero entries
         * in pitch_classes_present, false otherwise.
         */
        private static boolean checkNumberOfPitchClasses(int[] pitch_class_strengths,
                                                         int number_expected_pcs) {
<span class="fc" id="L391">            int count = 0;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">            for (int i = 0; i &lt; pitch_class_strengths.length; i++)</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (0 &lt; pitch_class_strengths[i])</span>
<span class="fc" id="L394">                    count++;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            return count == number_expected_pcs;</span>
        }


        /**
         * Check if all entries in the given to_check array are set to true.
         *
         * @param to_check The array to check.
         * @return True if all values in to_check are true, false otherwise.
         */
        private static boolean checkAllEntriesTrue(boolean[] to_check) {
<span class="fc bfc" id="L406" title="All 2 branches covered.">            for (int i = 0; i &lt; to_check.length; i++)</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if (!to_check[i])</span>
<span class="fc" id="L408">                    return false;</span>
<span class="fc" id="L409">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>